<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Help Haroon rescue Saaniya!</title>
    <!-- Tailwind CSS CDN for general page styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for game canvas and pixel art effects */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
            min-height: 100vh; /* Ensures it takes full viewport height */
            margin: 0;
            padding: 0; /* No default padding on body */
            box-sizing: border-box;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748; /* Darker container background */
            border-radius: 1rem; /* Rounded corners */
            padding: 1.5rem; /* Padding around content inside container */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            width: 100%; /* Take full available width of parent */
            max-width: 800px; /* Limit max width for larger screens */
            box-sizing: border-box;
            flex-grow: 1; /* Allows it to expand vertically */
            min-height: 0; /* Allow flex item to shrink below content size */
            overflow: auto; /* Allow scrolling inside the game container if content exceeds its height */
            margin: auto; /* Auto margins to push it to center if space available */
        }

        canvas {
            background-color: #7da5d9; /* Sky blue for background */
            border: 4px solid #a0aec0;
            border-radius: 0.5rem; /* Rounded corners for canvas */
            display: block;
            touch-action: none; /* Disable default touch actions like pan/zoom */
            /* Dimensions set by JavaScript for precise pixel art scaling */
            image-rendering: optimizeSpeed;             /* Older versions of FF */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+ */
            image-rendering: -webkit-optimize-contrast; /* Safari, Chrome */
            image-rendering: optimize-contrast;         /* IE 10+ */
            image-rendering: pixelated;                 /* Chrome 41+ and Opera */
            -ms-interpolation-mode: nearest-neighbor;   /* IE 7+ */
        }

        /* Message box is now hidden as text is drawn on canvas */
        .message-box {
            display: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Aligns with container max-width */
            margin-bottom: 0.5rem;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 0 0.5rem; /* Small padding to align with canvas visually */
            box-sizing: border-box;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 400px; /* Limit width for touch controls */
            justify-content: center;
        }

        .control-button {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            flex: 1; /* Distribute space evenly */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease, transform 0.1s ease;
            user-select: none; /* Prevent text selection on tap */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
        }

        .control-button:active {
            background-color: #2b6cb0; /* Darker blue on active */
            transform: translateY(2px); /* Press effect */
        }

        .restart-button, .next-level-button { /* Added .next-level-button */
            background-color: #e53e3e; /* Red for restart */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin-top: 1rem;
        }

        .next-level-button { /* Style specifically for next level button */
            background-color: #28a745; /* Green for next level */
        }

        .restart-button:active, .next-level-button:active {
            background-color: #c53030;
            transform: translateY(2px);
        }

        /* Responsive adjustments for overall layout */
        @media (min-width: 768px) {
            .game-container {
                padding: 2rem;
            }
            .game-info {
                font-size: 1.25rem;
            }
            .control-button {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl sm:text-4xl font-bold text-white mb-4 text-center">Help Haroon rescue Saaniya!</h1>
        <div class="game-info">
            <span id="scoreDisplay">Score: 0</span>
            <span id="levelDisplay">Level: 1</span>
        </div>
        <div id="message-box" class="message-box">Use Arrow Keys (Left/Right/Up) or Touch Controls to move and jump!</div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls"> <!-- Controls for all screen sizes -->
            <button id="leftButton" class="control-button">◀</button>
            <button id="jumpButton" class="control-button">JUMP</button>
            <button id="rightButton" class="control-button">▶</button>
        </div>
        <button id="restartButton" class="restart-button hidden">Restart Game</button>
        <button id="nextLevelButton" class="next-level-button hidden">Next Level</button> <!-- New button for next level -->
    </div>

    <script type="module">
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game configuration
        const gridSize = 32; // Size of each 'pixel' block (tile) in the game world
        const GRAVITY = 1.2;
        const JUMP_STRENGTH = -20; // Negative because Y-axis is inverted (up is -Y)
        const PLAYER_HORIZONTAL_SPEED = 6;
        let cameraX = 0; // Current camera offset for horizontal scrolling
        let cameraY = 0; // Current camera offset for vertical positioning (fixed to bottom of map)
        let gameLoopId = null; // To store the ID returned by requestAnimationFrame
        let gameFrameCounter = 0; // New: for consistent animation and enemy movement

        // Character definitions
        // Man (rescuer) - 8 rows x 4 columns for detail within 1 tile width, 2 tiles height
        const man = {
            initialX: 2 * gridSize,
            x: 0, y: 0, dx: 0, dy: 0,
            shape: [
                [0, 8, 8, 0], // Row 0: Hair/Head top (darker skin for hair/turban)
                [1, 9, 9, 1], // Row 1: Face with eye/mouth (skin, eye/mouth detail, skin)
                [1, 1, 1, 1], // Row 2: Lower face/neck/beard stubble area
                [3, 3, 3, 3], // Row 3: Upper Torso (Kameez)
                [3, 4, 4, 3], // Row 4: Mid Torso (Kameez with arm details)
                [5, 5, 5, 5], // Row 5: Upper Shalwar
                [5, 5, 5, 5], // Row 6: Mid Shalwar
                [6, 6, 6, 6]  // Row 7: Feet / Shoes - Default state
            ],
            // Alternate shape for walking animation (only feet change)
            walkingShape: [
                [0, 8, 8, 0],
                [1, 9, 9, 1],
                [1, 1, 1, 1],
                [3, 3, 3, 3],
                [3, 4, 4, 3],
                [5, 5, 5, 5],
                [5, 5, 5, 5],
                [7, 7, 7, 7]  // Row 7: Feet shifted (alternate state)
            ],
            colorMap: {
                0: 'transparent',
                1: '#f0c78c', // Skin tone
                2: '#e5b078', // Skin shadow / Face contour
                3: '#82b9e2', // Kameez (Light Blue)
                4: '#69a0d1', // Kameez darker shade/detail for folds/arms
                5: '#3d5c80', // Shalwar (Dark Blue)
                6: '#5c3a21', // Shoes (Brown) - Standing pose
                7: '#4a2f1a', // Shoes (Darker Brown) - Walking pose
                8: '#5c3a21', // Hair/Turban base color (can match shoes for consistency)
                9: '#000000'  // Eyes/Mouth (black)
            },
            width: gridSize, // Character is 1 tile wide (32 pixels)
            height: 2 * gridSize, // Character is 2 tiles tall (64 pixels)
            onGround: false,
            animationFrame: 0,
            animationSpeed: 5,
            isHit: false,
            hitTimer: 0
        };

        // Woman (to be rescued) - 8 rows x 4 columns for detail within 1 tile width, 2 tiles height
        const woman = {
            x: 0, y: 0,
            width: gridSize, // Character is 1 tile wide (32 pixels)
            height: 2 * gridSize, // Character is 2 tiles tall (64 pixels)
            shape: [
                [0, 8, 8, 0], // Row 0: Hair/Head top (could be a head covering too)
                [9, 1, 1, 9], // Row 1: Face with eyes/details (hair, skin, skin, hair)
                [0, 1, 1, 0], // Row 2: Lower face/neck/jewelry area
                [3, 3, 3, 3], // Row 3: Choli (top garment)
                [4, 4, 4, 4], // Row 4: Upper Lengha (skirt)
                [4, 5, 5, 4], // Row 5: Mid Lengha (with inner detail/fold to show volume)
                [4, 4, 4, 4], // Row 6: Lower Lengha (flowing out)
                [0, 6, 6, 0]  // Row 7: Heels (positioned slightly narrower at base)
            ],
            colorMap: {
                0: 'transparent',
                1: '#f0c78c', // Skin tone
                2: '#e5b078', // Face shade / Bindi detail
                3: '#e74c3c', // Choli (Vibrant Red)
                4: '#9b59b6', // Lengha (Royal Purple)
                5: '#7c4b92', // Lengha shade/detail for folds
                6: '#34495e', // Heels (Dark Grey/Black)
                8: '#8B4513', // Hair (Saddle Brown)
                9: '#000000'  // Eyes (black) / Bindi (small black dot)
            }
        };

        // Standard Enemy (Ground-based)
        const groundEnemyType = {
            shape: [
                [0, 0, 0, 0],
                [0, 1, 1, 0], // Head/Eyes
                [1, 2, 2, 1], // Body top
                [1, 2, 2, 1], // Body middle
                [1, 1, 1, 1], // Body bottom
                [0, 3, 3, 0], // Legs/Feet
                [0, 0, 0, 0]
            ],
            colorMap: {
                0: 'transparent',
                1: '#8B0000', // Dark Red body
                2: '#FF4500', // Orange-red highlights / eyes
                3: '#5C4033'  // Dark brown feet/base
            },
            width: gridSize,
            height: gridSize
        };

        // Flying Enemy
        const flyingEnemyType = {
            shape: [
                [0, 0, 0, 0],
                [1, 1, 1, 1], // Top wing segment
                [0, 2, 2, 0], // Body/eye
                [1, 1, 1, 1], // Bottom wing segment
                [0, 3, 3, 0], // Tail
                [0, 0, 0, 0]
            ],
            colorMap: {
                0: 'transparent',
                1: '#FFD700', // Gold wings
                2: '#DAA520', // Goldenrod body / shade
                3: '#8B0000'  // Dark Red for eyes/tail tip
            },
            width: gridSize,
            height: gridSize
        };


        // Enemy definition
        function createEnemy(x, y, speed, type = 'ground') {
            const enemyBase = { x, y, dx: speed, dy: 0, width: gridSize, height: gridSize };
            if (type === 'flying') {
                return { ...enemyBase, ...flyingEnemyType, initialY: y, verticalAmplitude: 30, verticalSpeed: 0.05, type: 'flying' }; // Reduced amplitude for smoother move
            }
            return { ...enemyBase, ...groundEnemyType, type: 'ground' };
        }
        let enemies = [];

        // Collectible definition (coins)
        function createCollectible(x, y) {
            return {
                x: x,
                y: y,
                width: gridSize / 2, // Half tile size for coins
                height: gridSize / 2,
                color: '#f1c40f', // Gold
                collected: false
            };
        }
        let collectibles = [];

        // Cloud definition
        function createCloud(x, y, width, height, speed) {
            return { x, y, width, height, speed, color: '#ecf0f1' }; // Light grey/white
        }
        let clouds = [];

        // Confetti particle definition
        function createConfettiParticle(x, y) {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
            return {
                x: x,
                y: y,
                size: Math.random() * 5 + 3, // Random size between 3 and 8
                dx: (Math.random() - 0.5) * 10, // Horizontal velocity
                dy: (Math.random() - 1) * 10,  // Upward initial velocity
                color: colors[Math.floor(Math.random() * colors.length)],
                lifetime: 60 + Math.random() * 60 // Lifetime in frames (1-2 seconds)
            };
        }
        let confettiParticles = []; // Array to hold confetti particles


        // Game Maps (separated by level)
        const gameMaps = {
            1: [
                // Row 0 (Sky)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                // Row 4 (Higher Platforms)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', 'C', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', ' ', ' ', ' ', 'C', ' ', ' ', ' ', 'C'],
                // Row 5 (Mid-level Platforms/Obstacles)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'O', 'O', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                // Row 6 (More Platforms)
                [' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' '],
                // Row 7 (Main Ground and Gaps)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', 'C', ' ', 'O', 'O', 'O', ' ', ' ', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
                // Row 8 (Obstacles/Ground)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'O', 'O', ' ', ' ', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
                // Row 9 (Bottom Layer - for falling into void)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G']
            ],
            2: [ // Level 2 - More challenging!
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // Platform with enemy wider
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'O', 'O', 'O', 'O', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // Obstacle is now 5 blocks wide, 'F' flying enemy strategically placed
                [' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', 'C', ' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' '], // New platform, new enemy
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'O', 'O', 'O', 'O', 'O', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'G', 'G'], // Taller obstacle after pit, 'O' is 2 tiles tall
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'O', 'O', 'O', 'O', 'O', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'G', 'G'],
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G']
            ]
        };
        let currentLevel = 1;
        let gameMap = []; // The game's active map, which can be modified
        let mapWidthTiles;
        let mapHeightTiles;
        let totalMapPixelWidth;
        let totalMapPixelHeight;

        // Game state variables
        let gameEnded = false; // When woman is rescued
        let gameOver = false; // When man dies
        let score = 0;
        let messageText = "Use Arrow Keys (Left/Right/Up)\nor Touch Controls to move and jump!"; // Text for overlay, now with newline
        let messageTimer = 180; // Display initial message for 3 seconds (60 frames per second * 3)
        let initialMessageActive = true; // New flag for initial message state
        let scoreDisplay = document.getElementById('scoreDisplay');
        let levelDisplay = document.getElementById('levelDisplay'); // New element for level display
        let restartButton = document.getElementById('restartButton');
        let nextLevelButton = document.getElementById('nextLevelButton'); // Reference to the new button

        // Keyboard input handling
        const keys = {
            ArrowLeft: false, ArrowRight: false, ArrowUp: false,
            a: false, d: false, w: false
        };

        // Event listeners for keyboard
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                if (initialMessageActive) { // Dismiss initial message on first key press
                    initialMessageActive = false;
                    messageTimer = 0; // Ensure it's immediately hidden
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        // Touch controls setup
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');
        restartButton.addEventListener('click', () => {
            // No longer reset to level 1 on 'restart' button click.
            // It will just restart the current level.
            resetGame();
        });
        nextLevelButton.addEventListener('click', () => {
            currentLevel++;
            resetGame();
        });

        function handleButtonPress(key, isPressed) {
            if (keys.hasOwnProperty(key)) {
                keys[key] = isPressed;
                if (initialMessageActive) { // Dismiss initial message on first button press
                    initialMessageActive = false;
                    messageTimer = 0; // Ensure it's immediately hidden
                }
            }
        }

        // Attach touch and mouse events to buttons
        [
            { button: leftButton, key: 'ArrowLeft' },
            { button: rightButton, key: 'ArrowRight' },
            { button: jumpButton, key: 'ArrowUp' }
        ].forEach(({ button, key }) => {
            // Mouse events
            button.addEventListener('mousedown', (e) => { e.preventDefault(); handleButtonPress(key, true); });
            button.addEventListener('mouseup', () => handleButtonPress(key, false));
            button.addEventListener('mouseleave', () => handleButtonPress(key, false)); // Release if mouse leaves button
            // Touch events
            button.addEventListener('touchstart', (e) => { e.preventDefault(); handleButtonPress(key, true); }, { passive: false });
            button.addEventListener('touchend', () => handleButtonPress(key, false));
            button.addEventListener('touchcancel', () => handleButtonPress(key, false));
        });

        // Function to check for intersection between two rectangles
        function intersectRect(r1, r2) {
            return !(r2.x >= r1.x + r1.width ||
                     r2.x + r2.width <= r1.x ||
                     r2.y >= r1.y + r1.height ||
                     r2.y + r2.height <= r1.y);
        }

        // Function to get the bounding box of a tile
        function getTileBoundingBox(tileX, tileY) {
            return {
                x: tileX * gridSize,
                y: tileY * gridSize,
                width: gridSize,
                height: gridSize
            };
        }


        // Function to resize canvas and initialize game positions
        function resizeGame() {
            const gameContainer = document.querySelector('.game-container');
            const style = getComputedStyle(gameContainer);
            const containerPaddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const containerPaddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);

            const headerHeight = document.querySelector('h1').offsetHeight;
            const gameInfoHeight = document.getElementById('scoreDisplay').parentElement.offsetHeight;
            const controlsHeight = document.querySelector('.controls').offsetHeight;
            // Get actual restart button height, accounting for 'hidden' class
            const restartButtonElement = document.getElementById('restartButton');
            const restartButtonHeight = restartButtonElement.classList.contains('hidden') ? 0 : restartButtonElement.offsetHeight;
            const nextLevelButtonElement = document.getElementById('nextLevelButton'); // Get next level button height
            const nextLevelButtonHeight = nextLevelButtonElement.classList.contains('hidden') ? 0 : nextLevelButtonElement.offsetHeight;


            // Calculate available width and height for canvas within the container,
            // subtracting static UI elements and container's own padding/margins.
            // We assume body itself has no significant padding/margin affecting this.
            let availableWidth = gameContainer.clientWidth - containerPaddingX;
            // Subtract UI elements from container's clientHeight, not viewport.
            // Use clientHeight of gameContainer as available space, not window.innerHeight.
            let uiElementsTotalHeight = headerHeight + gameInfoHeight + controlsHeight + restartButtonHeight + nextLevelButtonHeight + containerPaddingY;

            // Add a small buffer to prevent elements from touching edges too much
            uiElementsTotalHeight += 20; // Extra buffer for vertical space

            let availableHeight = window.innerHeight - uiElementsTotalHeight;

            // Determine optimal canvas dimensions maintaining 16:9 aspect ratio
            let targetWidth = availableWidth;
            let targetHeight = (targetWidth / 16) * 9;

            // If the calculated height is too large for the available vertical space,
            // constrain by height and re-calculate width.
            if (targetHeight > availableHeight) {
                targetHeight = availableHeight;
                targetWidth = (targetHeight / 9) * 16;
            }

            // Ensure dimensions are multiples of gridSize for pixel perfect rendering.
            // Also ensure a minimum size to prevent the canvas from becoming too small to see anything.
            const minCanvasWidth = gridSize * 15; // e.g., 15 tiles wide minimum
            const minCanvasHeight = gridSize * 9;  // e.g., 9 tiles tall minimum (for ground, character, some sky)

            canvas.width = Math.max(minCanvasWidth, Math.floor(targetWidth / gridSize) * gridSize);
            canvas.height = Math.max(minCanvasHeight, Math.floor(targetHeight / gridSize) * gridSize);

            // Set CSS width/height to fill its container while maintaining aspect ratio,
            // but ensure the internal resolution (canvas.width/height) remains correct for pixel art.
            // The `image-rendering: pixelated;` CSS property is essential here.
            canvas.style.width = '100%'; // Allow CSS to scale it visually
            canvas.style.height = 'auto'; // Maintain aspect ratio via CSS

            // Calculate fixed cameraY offset: ensures bottom of game world aligns with canvas bottom.
            // If the map's total height is less than the canvas's current height, cameraY will be negative,
            // so we clamp it at 0 to keep the top of the map visible.
            cameraY = totalMapPixelHeight - canvas.height;
            if (cameraY < 0) cameraY = 0; // Don't scroll above map top if map is shorter than canvas


            // Initial player and woman placement (absolute world coordinates)
            man.x = man.initialX;
            // Man's Y is placed on the second to last ground row of the map.
            // Ensure this is consistent with the map data.
            man.y = totalMapPixelHeight - (mapHeightTiles - 7) * gridSize - man.height;


            woman.x = (mapWidthTiles - 5) * gridSize; // 5 tiles from the right edge
            // Woman's Y is also placed on the second to last ground row.
            woman.y = totalMapPixelHeight - (mapHeightTiles - 7) * gridSize - woman.height;

            drawGame(); // Initial draw after resize and placement
        }

        // Initialize entities (enemies, collectibles, clouds) based on the map
        function initializeEntities() {
            enemies = [];
            collectibles = [];
            clouds = []; // Reset clouds for new game
            confettiParticles = []; // Clear any lingering confetti

            // Add some initial clouds (absolute map coordinates, will be drawn with parallax)
            clouds.push(createCloud(100, 50, 100, 40, 0.5));
            clouds.push(createCloud(500, 100, 150, 60, 0.3));
            clouds.push(createCloud(900, 70, 80, 30, 0.6));
            clouds.push(createCloud(200, 150, 120, 50, 0.4));

            // Use the current level's map data
            const currentMapData = gameMaps[currentLevel];
            mapWidthTiles = currentMapData[0].length;
            mapHeightTiles = currentMapData.length;
            totalMapPixelWidth = mapWidthTiles * gridSize;
            totalMapPixelHeight = mapHeightTiles * gridSize;


            // Create a deep copy of the original map for the current game session
            for(let i=0; i<currentMapData.length; i++) {
                gameMap[i] = [...currentMapData[i]];
            }

            for (let row = 0; row < mapHeightTiles; row++) {
                for (let col = 0; col < mapWidthTiles; col++) {
                    const tileType = gameMap[row][col];
                    const px = col * gridSize;
                    const py = row * gridSize;

                    if (tileType === 'E') {
                        // Place ground enemy
                        enemies.push(createEnemy(px, py + gridSize - (groundEnemyType.height), 2, 'ground'));
                        gameMap[row][col] = ' '; // Clear spawn point from map so it doesn't draw a tile
                    } else if (tileType === 'F') {
                         // Place flying enemy, slightly above the tile
                        enemies.push(createEnemy(px, py - (flyingEnemyType.height / 2), 1.5, 'flying'));
                        gameMap[row][col] = ' '; // Clear spawn point
                    }
                    else if (tileType === 'C') {
                        collectibles.push(createCollectible(px + gridSize / 4, py + gridSize / 4)); // Center coin in tile
                        gameMap[row][col] = ' '; // Clear collectible from map
                    }
                }
            }
        }

        // Get tile type at specific pixel coordinates
        function getTileAtPixel(px, py) {
            const tileX = Math.floor(px / gridSize);
            const tileY = Math.floor(py / gridSize);

            if (tileX >= 0 && tileX < mapWidthTiles && tileY >= 0 && tileY < mapHeightTiles) {
                return gameMap[tileY][tileX];
            }
            return ' '; // Treat out-of-bounds as empty space
        }

        // Draw a pixel art character (man/woman/enemy)
        function drawCharacter(character, cameraX, isWalking = false) {
            const drawX = character.x - cameraX;
            const drawY = character.y - cameraY; // Apply global cameraY offset

            // Determine the size of the individual 'pixels' within the character's shape
            // Assumes character.shape[0].length is consistent for all rows
            const charPixelDrawSizeX = character.width / character.shape[0].length;
            const charPixelDrawSizeY = character.height / character.shape.length;

            let currentShape = character.shape;

            // Apply walking animation for man
            if (isWalking && character === man) {
                const step = Math.floor(character.animationFrame / character.animationSpeed) % 2; // 0 or 1
                currentShape = (step === 0) ? man.shape : man.walkingShape;
            }

            // Apply hit animation (flashing) for the man
            if (character === man && man.isHit && (Math.floor(man.hitTimer / 5) % 2 === 0)) {
                return; // Skip drawing to create a flashing effect
            }

            // Draw each pixel of the character's shape
            currentShape.forEach((row, rowIndex) => {
                row.forEach((pixelType, colIndex) => {
                    const color = character.colorMap[pixelType];
                    if (color && color !== 'transparent') {
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            drawX + colIndex * charPixelDrawSizeX,
                            drawY + rowIndex * charPixelDrawSizeY,
                            charPixelDrawSizeX,
                            charPixelDrawSizeY
                        );
                    }
                });
            });
        }

        // Draw the game map
        function drawMap(cameraX, cameraY) {
            const startCol = Math.floor(cameraX / gridSize);
            const endCol = startCol + Math.ceil(canvas.width / gridSize) + 1;

            for (let row = 0; row < mapHeightTiles; row++) {
                for (let col = startCol; col < endCol; col++) {
                    const tileType = getTileAtPixel(col * gridSize, row * gridSize);
                    const drawX = col * gridSize - cameraX;
                    const drawY = row * gridSize - cameraY;

                    if (tileType === 'G') {
                        ctx.fillStyle = '#654321'; // Brown for ground
                        ctx.fillRect(drawX, drawY, gridSize, gridSize);
                        // Add some grass tops
                        ctx.fillStyle = '#228B22'; // Forest green
                        ctx.fillRect(drawX, drawY, gridSize, gridSize / 4);
                    } else if (tileType === 'O') {
                        ctx.fillStyle = '#7f8c8d'; // Grey for obstacles (rocks/bricks)
                        ctx.fillRect(drawX, drawY, gridSize, gridSize);
                        // Add simple brick lines for castle-like appearance
                        ctx.strokeStyle = '#525e60';
                        ctx.lineWidth = 2;
                        // Horizontal lines
                        ctx.beginPath();
                        ctx.moveTo(drawX, drawY + gridSize / 4);
                        ctx.lineTo(drawX + gridSize, drawY + gridSize / 4);
                        ctx.moveTo(drawX, drawY + gridSize / 2);
                        ctx.lineTo(drawX + gridSize, drawY + gridSize / 2);
                        ctx.moveTo(drawX, drawY + (3 * gridSize) / 4);
                        ctx.lineTo(drawX + gridSize, drawY + (3 * gridSize) / 4);
                        ctx.stroke();
                        // Vertical lines (staggered)
                        ctx.beginPath();
                        ctx.moveTo(drawX + gridSize / 2, drawY);
                        ctx.lineTo(drawX + gridSize / 2, drawY + gridSize / 4);
                        ctx.moveTo(drawX + gridSize / 4, drawY + gridSize / 2);
                        ctx.lineTo(drawX + gridSize / 4, drawY + (3 * gridSize) / 4);
                        ctx.moveTo(drawX + (3 * gridSize) / 4, drawY + gridSize / 4);
                        ctx.lineTo(drawX + (3 * gridSize) / 4, drawY + gridSize / 2);
                        ctx.moveTo(drawX + gridSize / 2, drawY + (3 * gridSize) / 4);
                        ctx.lineTo(drawX + gridSize / 2, drawY + gridSize);
                        ctx.stroke();

                    } else if (tileType === 'P') {
                        ctx.fillStyle = '#27ae60'; // Green for platforms
                        ctx.fillRect(drawX, drawY, gridSize, gridSize / 2); // Thinner platform
                        ctx.fillStyle = '#1e8449'; // Darker green underside
                        ctx.fillRect(drawX, drawY + gridSize / 2, gridSize, gridSize / 2);
                    }
                }
            }
        }

        // Draw the castle background elements
        function drawBackground(cameraX, cameraY) {
            // Sky is handled by canvas background-color CSS (light blue)
            ctx.fillStyle = '#7da5d9'; // Sky blue
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const castleColor = '#a9a9a9';
            const windowColor = '#fdfd96';
            const turretColor = '#808080';
            const battlementColor = '#696969';
            const flagColor = '#e74c3c';
            const deepGroundColor = '#212121'; // Dark, earthy color for deep ground/void

            // Calculate the absolute Y coordinate of the main ground level in the world
            // (assuming row 7 is where the main ground starts in the map data)
            const mapGroundAbsoluteY = totalMapPixelHeight - (mapHeightTiles - 7) * gridSize;

            // Draw the deep ground/void layer, extending downwards from the visible ground level
            // This fills any area below the playable map's ground that the camera might show
            ctx.fillStyle = deepGroundColor;
            ctx.fillRect(0, mapGroundAbsoluteY - cameraY, canvas.width, canvas.height - (mapGroundAbsoluteY - cameraY));

            // Parallax offset for background elements
            const parallaxOffsetX = cameraX * 0.5;
            const parallaxOffsetY = cameraY * 0.5; // Apply parallax to Y as well

            const backgroundRepeatWidth = gridSize * 15;

            const startDrawX = - (parallaxOffsetX % backgroundRepeatWidth);
            const numRepeats = Math.ceil((canvas.width + backgroundRepeatWidth) / backgroundRepeatWidth) + 1;

            // Define castle base drawing Y relative to mapGroundAbsoluteY
            const castleTopRelativeToGround = 3 * gridSize; // How many grid units the castle wall extends UP from the map ground
            const castleWallDrawY = mapGroundAbsoluteY - castleTopRelativeToGround - parallaxOffsetY;

            // Define how much the castle extends *below* the visible map ground
            const castleFoundationDepth = 5 * gridSize; // Extend 5 grid units below ground
            
            for (let i = 0; i < numRepeats + 1; i++) {
                const currentSectionX = startDrawX + i * backgroundRepeatWidth;

                // --- Base Wall (extended downwards) ---
                const wallTotalHeight = castleTopRelativeToGround + castleFoundationDepth;
                ctx.fillStyle = castleColor;
                ctx.fillRect(currentSectionX, castleWallDrawY, gridSize * 15, wallTotalHeight);

                // --- Main Towers (Taller) ---
                const mainTurretHeight = 4 * gridSize;
                const mainTurretDrawY = castleWallDrawY - mainTurretHeight; // Relative to the top of the wall
                ctx.fillStyle = turretColor;
                ctx.fillRect(currentSectionX + 1 * gridSize, mainTurretDrawY, 2 * gridSize, mainTurretHeight); // Left tall turret
                ctx.fillRect(currentSectionX + 12 * gridSize, mainTurretDrawY, 2 * gridSize, mainTurretHeight); // Right tall turret

                // --- Smaller Tower ---
                const shortTurretHeight = 2 * gridSize;
                const shortTurretDrawY = castleWallDrawY - shortTurretHeight; // Relative to the top of the wall
                ctx.fillStyle = turretColor;
                ctx.fillRect(currentSectionX + 6 * gridSize, shortTurretDrawY, 2 * gridSize, shortTurretHeight); // Mid short turret

                // --- Battlement details ---
                ctx.fillStyle = battlementColor;
                // Top of walls
                for (let j = 0; j < 15; j++) {
                    if (j % 2 === 0) {
                        ctx.fillRect(currentSectionX + j * gridSize, castleWallDrawY, gridSize, gridSize / 2);
                    }
                }
                // Tower battlements (adjust relative to their turret base)
                ctx.fillRect(currentSectionX + 1 * gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);
                ctx.fillRect(currentSectionX + 1 * gridSize + gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);
                ctx.fillRect(currentSectionX + 12 * gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);
                ctx.fillRect(currentSectionX + 12 * gridSize + gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);

                // --- Windows ---
                ctx.fillStyle = windowColor;
                ctx.fillRect(currentSectionX + 3 * gridSize, castleWallDrawY + (0.5 * gridSize), gridSize, gridSize); // Main wall window 1
                ctx.fillRect(currentSectionX + 9 * gridSize, castleWallDrawY + (0.5 * gridSize), gridSize, gridSize); // Main wall window 2

                ctx.fillRect(currentSectionX + 1.5 * gridSize, mainTurretDrawY + gridSize, gridSize, gridSize / 2); // Left turret window
                ctx.fillRect(currentSectionX + 12.5 * gridSize, mainTurretDrawY + gridSize, gridSize, gridSize / 2); // Right turret window

                // Arched window (simple representation)
                ctx.fillStyle = windowColor;
                ctx.fillRect(currentSectionX + 6.5 * gridSize, shortTurretDrawY + gridSize / 2, gridSize, gridSize / 2);
                ctx.fillRect(currentSectionX + 6.5 * gridSize + gridSize / 4, shortTurretDrawY + gridSize, gridSize / 2, gridSize / 2); // Arch top


                // --- Flag ---
                // Flagpole top: mainTurretDrawY - gridSize - 10px
                ctx.fillStyle = flagColor;
                ctx.fillRect(currentSectionX + 1.5 * gridSize + gridSize / 2 - 2, mainTurretDrawY - gridSize - 10, 4, gridSize + 10); // Flagpole
                ctx.fillRect(currentSectionX + 1.5 * gridSize + gridSize / 2 - 2, mainTurretDrawY - gridSize - 10, gridSize, gridSize / 2); // Flag fabric
            }

            // Draw clouds
            clouds.forEach(cloud => {
                ctx.fillStyle = cloud.color;
                ctx.beginPath();
                // Apply parallax to clouds' Y position as well
                ctx.arc(cloud.x - parallaxOffsetX + cloud.width * 0.2, cloud.y - parallaxOffsetY + cloud.height * 0.5, cloud.height * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x - parallaxOffsetX + cloud.width * 0.5, cloud.y - parallaxOffsetY + cloud.height * 0.3, cloud.height * 0.7, 0, Math.PI * 2);
                ctx.arc(cloud.x - parallaxOffsetX + cloud.width * 0.8, cloud.y - parallaxOffsetY + cloud.height * 0.5, cloud.height * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Helper function to wrap text into multiple lines based on max width
        function getWrappedTextLines(context, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0] || '';

            if (words.length === 0) return [""];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + ' ' + word;
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxWidth && i > 0) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Function to draw overlay text on the canvas, now supports multiple lines
        function drawOverlayMessage(message) {
            // Dynamically adjust font size based on canvas width, clamped
            const maxFontSize = 48;
            const minFontSize = 24;
            let fontSize = Math.min(maxFontSize, Math.max(minFontSize, canvas.width * 0.06));
            ctx.font = `bold ${fontSize}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;

            // Handle explicit newlines first, then wrap remaining lines
            const segmentsByExplicitNewline = message.split('\n');
            let finalLines = [];
            const maxWidth = canvas.width * 0.8; // 80% of canvas width

            segmentsByExplicitNewline.forEach(segment => {
                const wrappedLinesInSegment = getWrappedTextLines(ctx, segment, maxWidth);
                finalLines = finalLines.concat(wrappedLinesInSegment);
            });
            
            const lineHeight = fontSize + 12; // Adjusted line height for spacing
            const totalTextHeight = finalLines.length * lineHeight;
            const startY = (canvas.height / 2) - (totalTextHeight / 2) + (lineHeight / 2);

            const x = canvas.width / 2;

            finalLines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                ctx.strokeText(line, x, y);
                ctx.fillText(line, x, y);
            });
        }

        // Function to spawn confetti particles
        function spawnConfetti() {
            confettiParticles = []; // Clear existing confetti
            // Spawn confetti at the center of the woman's current visible position
            const spawnX = woman.x + woman.width / 2;
            const spawnY = woman.y + woman.height / 2;

            for (let i = 0; i < 100; i++) { // Spawn 100 particles
                confettiParticles.push(createConfettiParticle(spawnX, spawnY));
            }
        }


        // Update game logic (physics, movement, collisions)
        function updateGame() {
            // Decrement message timer if active
            if (initialMessageActive && messageTimer > 0) {
                messageTimer--;
                if (messageTimer <= 0) {
                    initialMessageActive = false;
                }
            }

            // Only update game physics and character/enemy movement if game is active
            if (!gameEnded && !gameOver) {
                // --- Apply Gravity to Man ---
                man.dy += GRAVITY;

                // --- Horizontal Movement for Man ---
                let movedHorizontally = false;
                man.dx = 0;
                if (keys.ArrowLeft || keys.a) {
                    man.dx = -PLAYER_HORIZONTAL_SPEED;
                    movedHorizontally = true;
                }
                if (keys.ArrowRight || keys.d) {
                    man.dx = PLAYER_HORIZONTAL_SPEED;
                    movedHorizontally = true;
                }

                let nextManRectX = { // Rectangle for potential X movement
                    x: man.x + man.dx,
                    y: man.y,
                    width: man.width,
                    height: man.height
                };

                // Horizontal collision with map boundaries and tiles
                const x1 = Math.floor(nextManRectX.x / gridSize);
                const x2 = Math.ceil((nextManRectX.x + nextManRectX.width) / gridSize);
                const y1 = Math.floor(nextManRectX.y / gridSize);
                const y2 = Math.ceil((nextManRectX.y + nextManRectX.height) / gridSize);

                for (let row = y1; row < y2; row++) {
                    for (let col = x1; col < x2; col++) {
                        const tileType = getTileAtPixel(col * gridSize, row * gridSize);
                        if (['G', 'O', 'P'].includes(tileType)) {
                            const tileRect = getTileBoundingBox(col, row);
                            if (intersectRect(nextManRectX, tileRect)) {
                                if (man.dx > 0) { // Moving right, hit left side of tile
                                    man.x = tileRect.x - man.width;
                                } else if (man.dx < 0) { // Moving left, hit right side of tile
                                    man.x = tileRect.x + tileRect.width;
                                }
                                man.dx = 0; // Stop horizontal movement
                                break; // Collision resolved, stop checking this row horizontally
                            }
                        }
                    }
                }
                if (man.dx !== 0) { // Only apply if no collision or resolved without stopping
                    man.x += man.dx;
                }


                // Update animation frame if moving
                if (movedHorizontally && man.onGround) {
                    man.animationFrame++;
                } else {
                    man.animationFrame = 0; // Reset animation when not walking
                }


                // --- Vertical Movement for Man ---
                let nextManRectY = { // Rectangle for potential Y movement
                    x: man.x, // Use resolved X position
                    y: man.y + man.dy,
                    width: man.width,
                    height: man.height
                };

                man.onGround = false; // Assume not on ground until proven otherwise

                // Vertical collision with map boundaries and tiles
                const vy1 = Math.floor(nextManRectY.y / gridSize);
                const vy2 = Math.ceil((nextManRectY.y + nextManRectY.height) / gridSize);
                const vx1 = Math.floor(nextManRectY.x / gridSize);
                const vx2 = Math.ceil((nextManRectY.x + nextManRectY.width) / gridSize);

                for (let row = vy1; row < vy2; row++) {
                    for (let col = vx1; col < vx2; col++) {
                        const tileType = getTileAtPixel(col * gridSize, row * gridSize);
                        if (['G', 'O', 'P'].includes(tileType)) {
                            const tileRect = getTileBoundingBox(col, row);
                            if (intersectRect(nextManRectY, tileRect)) {
                                if (man.dy > 0) { // Falling, hit top side of tile
                                    man.y = tileRect.y - man.height;
                                    man.onGround = true; // Landed on ground
                                } else if (man.dy < 0) { // Jumping/moving up, hit bottom side of tile
                                    man.y = tileRect.y + tileRect.height;
                                }
                                man.dy = 0; // Stop vertical movement
                                break; // Collision resolved, stop checking this row vertically
                            }
                        }
                    }
                }
                if (man.dy !== 0) { // Only apply if no collision or resolved without stopping
                    man.y += man.dy;
                }


                // Boundary check for falling off the bottom of the map
                if (man.y > totalMapPixelHeight + (2 * gridSize)) { // Allow falling 2 grid units below map's defined bottom
                    gameOver = true;
                    messageText = "Game Over!\nYou fell into the void!"; // Updated for multiline
                    restartButton.classList.remove('hidden');
                    nextLevelButton.classList.add('hidden'); // Hide next level button on game over
                    return; // Exit updateGame for this frame as game is over
                }

                // Jump input
                if ((keys.ArrowUp || keys.w) && man.onGround) {
                    man.dy = JUMP_STRENGTH;
                    man.onGround = false;
                }

                // Update Enemies (only if game is active)
                enemies.forEach(enemy => {
                    if (enemy.type === 'ground') {
                        // Apply gravity to enemy
                        enemy.dy += GRAVITY;
                        enemy.y += enemy.dy;

                        // Vertical collision for enemy (landing)
                        let nextEnemyY = enemy.y + enemy.dy;
                        const enemyBottomTileRow = Math.floor((nextEnemyY + enemy.height) / gridSize);
                        const enemyLeftCol = Math.floor(enemy.x / gridSize);
                        const enemyRightCol = Math.floor((enemy.x + enemy.width - 1) / gridSize);

                        let enemyOnGround = false;
                        for (let col = enemyLeftCol; col <= enemyRightCol; col++) {
                            const tileType = getTileAtPixel(col * gridSize, enemyBottomTileRow * gridSize);
                            if (['G', 'O', 'P'].includes(tileType)) {
                                const tileRect = getTileBoundingBox(col, enemyBottomTileRow);
                                if (intersectRect({ x: enemy.x, y: nextEnemyY, width: enemy.width, height: enemy.height }, tileRect)) {
                                    enemy.y = tileRect.y - enemy.height; // Snap to top of tile
                                    enemy.dy = 0;
                                    enemyOnGround = true;
                                    break;
                                }
                            }
                        }

                        enemy.x += enemy.dx; // Apply horizontal movement

                        // Enemy turning logic (wall and ledge detection and princess boundary)
                        let turnAround = false;

                        // Check for walls at current position after horizontal move
                        let checkX_wall_current = enemy.dx > 0 ? enemy.x + enemy.width : enemy.x;
                        let wallTile_current = getTileAtPixel(checkX_wall_current, enemy.y + enemy.height / 2);
                        if (['G', 'O', 'P'].includes(wallTile_current)) {
                            turnAround = true;
                        }

                        // Check for ledges (ahead of current position, below feet)
                        let checkX_ledge = enemy.dx > 0 ? enemy.x + enemy.width + 1 : enemy.x - 1; // 1 pixel outside current bounds
                        let checkY_ledge = enemy.y + enemy.height + 1; // 1 pixel below enemy's feet
                        let ledgeTile = getTileAtPixel(checkX_ledge, checkY_ledge);

                        if (enemyOnGround && !['G', 'O', 'P'].includes(ledgeTile)) {
                            turnAround = true;
                        }

                        // Check for map boundaries
                        if (enemy.x < 0 || enemy.x + enemy.width > totalMapPixelWidth) {
                            turnAround = true;
                        }

                        // NEW: Enemy does not go past the woman's initial spawn X (left side)
                        // For Level 1 ground enemy, it should patrol the platform and not go past woman.x
                        if (currentLevel === 1) {
                            const patrolLeftBound = 24 * gridSize; // Column 24 (where enemy spawns)
                            const patrolRightBound = woman.x; // Woman's initial X is the right boundary

                            if (enemy.dx > 0 && enemy.x + enemy.width >= patrolRightBound) {
                                turnAround = true;
                            } else if (enemy.dx < 0 && enemy.x <= patrolLeftBound) {
                                turnAround = true;
                            }
                        } else {
                             // General map boundary check for other levels' ground enemies
                             if (enemy.x < 0 || enemy.x + enemy.width > totalMapPixelWidth) {
                                turnAround = true;
                            }
                        }

                        if (turnAround) {
                            enemy.dx *= -1; // Reverse direction
                        }
                    } else if (enemy.type === 'flying') {
                        // Flying enemy movement: oscillate vertically and move horizontally
                        enemy.y = enemy.initialY + Math.sin(gameFrameCounter * enemy.verticalSpeed) * enemy.verticalAmplitude;
                        enemy.x += enemy.dx;

                        // Reverse horizontal direction if hitting map boundaries or princess boundary
                        if (enemy.x < 0 || enemy.x + enemy.width > totalMapPixelWidth) {
                            enemy.dx *= -1;
                        }
                        // To prevent flying enemy from passing princess's approximate area:
                        // This logic should be carefully applied based on flying enemy's spawn location relative to woman.
                        // For Level 2, the flying enemy is far from the princess. It just needs to stay in bounds.
                        // The general map boundary check above is sufficient for flying enemies if they are not near the princess.
                    }
                });

                // --- Check Collisions (Man vs. Enemies, Man vs. Collectibles) ---
                enemies.forEach(enemy => {
                    if (!man.isHit && // Only take damage if not currently invincible
                        man.x < enemy.x + enemy.width &&
                        man.x + man.width > enemy.x &&
                        man.y < enemy.y + enemy.height &&
                        man.y + man.height > enemy.y
                    ) {
                        gameOver = true;
                        messageText = "Game Over!\nYou were caught by an enemy!"; // Updated for multiline
                        restartButton.classList.remove('hidden');
                        nextLevelButton.classList.add('hidden'); // Hide next level button on game over
                    }
                });

                collectibles.forEach(collectible => {
                    if (!collectible.collected &&
                        man.x < collectible.x + collectible.width &&
                        man.x + man.width > collectible.x &&
                        man.y < collectible.y + collectible.height &&
                        man.y + man.height > collectible.y
                    ) {
                        collectible.collected = true;
                        score += 100; // Add score for collecting
                        scoreDisplay.textContent = `Score: ${score}`;
                    }
                });

                // Handle man being hit (invincibility timer) - outside collision checks
                if (man.isHit) {
                    man.hitTimer--;
                    if (man.hitTimer <= 0) {
                        man.isHit = false; // Invincibility wears off
                    }
                }

                // Check for rescue collision (only if game is active)
                checkRescueCollision();
            }

            // Always update clouds and confetti, regardless of game state
            // Clouds are for background animation
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x - cameraX > canvas.width + cloud.width) {
                    cloud.x = cameraX - cloud.width - (Math.random() * 200);
                    cloud.y = Math.random() * (canvas.height / 3);
                }
            });

            // Confetti particles continue animating after game ends
            confettiParticles = confettiParticles.filter(p => {
                p.dy += GRAVITY * 0.5; // Confetti falls slower
                p.x += p.dx;
                p.y += p.dy;
                p.lifetime--;
                return p.lifetime > 0; // Keep particle if still alive
            });

            // Update camera position to follow the man, clamped to map boundaries
            // This needs to be outside the !gameEnded && !gameOver block
            // because camera should still follow the man if he's falling into the void
            cameraX = man.x - canvas.width / 2 + man.width / 2;
            cameraX = Math.max(0, Math.min(cameraX, totalMapPixelWidth - canvas.width));
            
            // Adjust cameraY to follow the player vertically
            // Clamped within the map height
            cameraY = man.y - (canvas.height / 2) + (man.height / 2);
            cameraY = Math.max(0, Math.min(cameraY, totalMapPixelHeight - canvas.height));
            if (cameraY < 0) cameraY = 0; // Ensure camera doesn't go above top of map
        }

        // Check if man has rescued the woman
        function checkRescueCollision() {
            if (
                man.x < woman.x + woman.width &&
                man.x + man.width > woman.x &&
                man.y < woman.y + woman.height &&
                man.y + man.height > woman.y
            ) {
                if (!gameEnded) { // Only trigger confetti once
                    spawnConfetti();
                }
                gameEnded = true;
                if (currentLevel < Object.keys(gameMaps).length) {
                    messageText = `Level ${currentLevel} Complete!\nPress 'Next Level' to continue.`;
                    nextLevelButton.classList.remove('hidden');
                    restartButton.classList.add('hidden'); // Hide restart if next level is available
                } else {
                    messageText = "You rescued her!\nAll levels complete!";
                    nextLevelButton.classList.add('hidden'); // No more levels
                    restartButton.classList.remove('hidden'); // Only restart is an option
                }
            }
        }

        // Draw everything on the canvas
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            drawBackground(cameraX, cameraY); // Pass cameraY
            drawMap(cameraX, cameraY); // Pass cameraY

            // Draw enemies
            enemies.forEach(enemy => {
                drawCharacter(enemy, cameraX); // Pass enemy object directly
            });

            // Draw collectibles
            collectibles.forEach(collectible => {
                if (!collectible.collected) {
                    ctx.fillStyle = collectible.color;
                    ctx.beginPath();
                    // Apply cameraY to collectible drawing
                    ctx.arc(collectible.x - cameraX + collectible.width / 2, collectible.y - cameraY + collectible.height / 2, collectible.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#e67e22'; // Darker orange for coin outline
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            drawCharacter(man, cameraX, man.dx !== 0); // cameraY handled internally by drawCharacter
            drawCharacter(woman, cameraX); // cameraY handled internally by drawCharacter

            // Draw confetti particles
            confettiParticles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - cameraX, p.y - cameraY, p.size, p.size); // Apply cameraY
            });

            // Draw overlay messages if game is ended or over OR if it's the initial message
            if (gameEnded || gameOver || initialMessageActive) { // Show message only if game is over/ended or initial message is active
                drawOverlayMessage(messageText);
            }
        }

        // Reset game state for restart or next level
        function resetGame() {
            // Cancel any existing game loop to prevent speed increase
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            gameEnded = false;
            gameOver = false;
            score = 0; // Reset score for new level
            scoreDisplay.textContent = `Score: ${score}`;
            levelDisplay.textContent = `Level: ${currentLevel}`; // Update level display
            messageText = "Use Arrow Keys (Left/Right/Up)\nor Touch Controls to move and jump!"; // Reset initial message
            messageTimer = 180; // Reset timer for initial message
            initialMessageActive = true; // Set initial message back to active
            restartButton.classList.add('hidden');
            nextLevelButton.classList.add('hidden');

            // Re-initialize map and entities for a fresh start for the new level
            initializeEntities();
            resizeGame(); // Re-position man and woman, redraw
            man.dx = 0; man.dy = 0; // Reset velocities
            man.onGround = false;
            man.isHit = false; // Reset hit state
            man.hitTimer = 0; // Reset hit timer
            confettiParticles = []; // Clear confetti
            gameFrameCounter = 0; // Reset frame counter for new level

            // Start a new game loop
            gameLoop();
        }


        // Game loop
        function gameLoop() {
            gameLoopId = requestAnimationFrame(gameLoop); // Assign ID to gameLoopId
            gameFrameCounter++; // Increment frame counter
            updateGame(); // Update game state
            drawGame();   // Redraw based on new state
        }

        // Initialize the game when the window loads
        window.onload = function () {
            initializeEntities(); // Populate enemies and collectibles based on map
            resizeGame(); // Initial resize and character/woman placement
            window.addEventListener('resize', resizeGame); // Add resize listener
            gameLoop(); // Start the game loop
        };
    </script>
</body>
</html>
