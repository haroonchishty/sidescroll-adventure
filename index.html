<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Help Haroon rescue Saaniya!</title>
    <!-- Tailwind CSS CDN for general page styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for game canvas and pixel art effects */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
            min-height: 100vh; /* Ensures it takes full viewport height */
            margin: 0;
            padding: 0; /* No default padding on body */
            box-sizing: border-box;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748; /* Darker container background */
            border-radius: 1rem; /* Rounded corners */
            padding: 1.5rem; /* Padding around content inside container */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            width: 100%; /* Take full available width of parent */
            max-width: 800px; /* Limit max width for larger screens */
            box-sizing: border;
            flex-grow: 1; /* Allows it to expand vertically */
            min-height: 0; /* Allow flex item to shrink below content size */
            overflow: auto; /* Allow scrolling inside the game container if content exceeds its height */
            margin: auto; /* Auto margins to push it to center if space available */
        }

        canvas {
            background-color: #7da5d9; /* Sky blue for background */
            border: 4px solid #a0aec0;
            border-radius: 0.5rem; /* Rounded corners for canvas */
            display: block;
            touch-action: none; /* Disable default touch actions like pan/zoom */
            /* Dimensions set by JavaScript for precise pixel art scaling */
            image-rendering: optimizeSpeed;             /* Older versions of FF */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+ */
            image-rendering: -webkit-optimize-contrast; /* Safari, Chrome */
            image-rendering: optimize-contrast;         /* IE 10+ */
            image-rendering: pixelated;                 /* Chrome 41+ and Opera */
            -ms-interpolation-mode: nearest-neighbor;   /* IE 7+ */
        }

        /* Message box is now hidden as text is drawn on canvas */
        .message-box {
            display: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px; /* Aligns with container max-width */
            margin-bottom: 0.5rem;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 0 0.5rem; /* Small padding to align with canvas visually */
            box-sizing: border-box;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 400px; /* Limit width for touch controls */
            justify-content: center;
        }

        .control-button {
            background-color: #4299e1; /* Blue button */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            flex: 1; /* Distribute space evenly */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease, transform 0.1s ease;
            user-select: none; /* Prevent text selection on tap */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
        }

        .control-button:active {
            background-color: #2b6cb0; /* Darker blue on active */
            transform: translateY(2px); /* Press effect */
        }

        .restart-button, .next-level-button, .play-again-button { /* Added .next-level-button, .play-again-button */
            background-color: #e53e3e; /* Red for restart */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin-top: 1rem;
        }

        .next-level-button { /* Style specifically for next level button */
            background-color: #28a745; /* Green for next level */
        }

        .play-again-button { /* Style specifically for play again button */
            background-color: #4CAF50; /* Green */
        }

        .restart-button:active, .next-level-button:active, .play-again-button:active {
            background-color: #c53030;
            transform: translateY(2px);
        }

        .level-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 400px;
            justify-content: center;
        }

        .level-button {
            background-color: #4a5568; /* Gray for level buttons */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            flex: 1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }

        .level-button:not(.disabled):hover {
            background-color: #2d3748;
        }

        .level-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #718096;
        }

        .level-button.current-level {
            background-color: #2b6cb0; /* Highlight current level */
            border: 2px solid #63b3ed;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl sm:text-4xl font-bold text-white mb-4 text-center">Help Haroon rescue Saaniya!</h1>
        <div class="game-info">
            <span id="scoreDisplay">Score: 0/0</span>
            <span id="levelDisplay">Level: 1</span>
            <span id="deathCounter">Deaths: 0</span>
        </div>
        <div id="message-box" class="message-box">Use Arrow Keys (Left/Right/Up) or Touch Controls to move and jump!</div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls"> <!-- Controls for all screen sizes -->
            <button id="leftButton" class="control-button">◀</button>
            <button id="jumpButton" class="control-button">JUMP</button>
            <button id="rightButton" class="control-button">▶</button>
        </div>
        <button id="restartButton" class="restart-button hidden">Restart Level</button>
        <button id="nextLevelButton" class="next-level-button hidden">Next Level</button>
        <button id="playAgainButton" class="play-again-button hidden">Play Again from Level 1</button>

        <div class="level-selector" id="levelSelector">
            <button id="level1Button" class="level-button current-level" data-level="1">Level 1</button>
            <button id="level2Button" class="level-button disabled" data-level="2">Level 2</button>
            <button id="level3Button" class="level-button disabled" data-level="3">Level 3</button>
        </div>
    </div>

    <script type="module">
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game configuration
        const gridSize = 32; // Size of each 'pixel' block (tile) in the game world
        const GRAVITY = 1.2;
        const JUMP_STRENGTH = -20; // Negative because Y-axis is inverted (up is -Y)
        const PLAYER_HORIZONTAL_SPEED = 6;
        let cameraX = 0; // Current camera offset for horizontal scrolling
        let cameraY = 0; // Current camera offset for vertical positioning (fixed to bottom of map)
        let gameLoopId = null; // To store the ID returned by requestAnimationFrame
        let gameFrameCounter = 0; // New: for consistent animation and enemy movement

        // Character definitions
        // Man (rescuer) - 8 rows x 4 columns for detail within 1 tile width, 2 tiles height
        const man = {
            initialX: 2 * gridSize,
            x: 0, y: 0, dx: 0, dy: 0,
            shape: [
                [0, 8, 8, 0], // Hair/Head top
                [1, 9, 9, 1], // Face with eye/mouth
                [1, 1, 1, 1], // Lower face/neck/beard stubble area
                [3, 3, 3, 3], // Upper Torso (Kameez)
                [3, 4, 4, 3], // Mid Torso (Kameez with arm details)
                [5, 5, 5, 5], // Upper Shalwar
                [5, 5, 5, 5], // Mid Shalwar
                [6, 6, 6, 6]  // Feet / Shoes - Default state
            ],
            // Alternate shape for walking animation (only feet and subtle body/arm change)
            walkingShape: [
                [0, 8, 8, 0],
                [1, 9, 9, 1],
                [1, 1, 1, 1],
                [3, 3, 3, 3], // Arms slightly forward/back
                [4, 3, 3, 4], // Torso subtly shifts
                [5, 5, 5, 5],
                [5, 5, 5, 5],
                [7, 7, 7, 7]  // Feet shifted (alternate state)
            ],
            colorMap: {
                0: 'transparent',
                1: '#f0c78c', // Skin tone
                2: '#e5b078', // Skin shadow / Face contour
                3: '#82b9e2', // Kameez (Light Blue)
                4: '#69a0d1', // Kameez darker shade/detail for folds/arms
                5: '#3d5c80', // Shalwar (Dark Blue)
                6: '#5c3a21', // Shoes (Brown) - Standing pose
                7: '#4a2f1a', // Shoes (Darker Brown) - Walking pose
                8: '#5c3a21', // Hair/Turban base color (can match shoes for consistency)
                9: '#000000'  // Eyes/Mouth (black)
            },
            width: gridSize, // Character is 1 tile wide (32 pixels)
            height: 2 * gridSize, // Character is 2 tiles tall (64 pixels)
            onGround: false,
            animationFrame: 0,
            animationSpeed: 5,
            isHit: false,
            hitTimer: 0,
            currentDirection: 'right'
        };

        // Woman (to be rescued) - 8 rows x 4 columns for detail within 1 tile width, 2 tiles height
        const woman = {
            x: 0, y: 0,
            width: gridSize, // Character is 1 tile wide (32 pixels)
            height: 2 * gridSize, // Character is 2 tiles tall (64 pixels)
            shape: [
                [0, 8, 8, 0], // Hair/Head top
                [9, 1, 1, 9], // Face with eyes/details
                [0, 1, 1, 0], // Lower face/neck/jewelry area
                [3, 3, 3, 3], // Choli (top garment)
                [4, 4, 4, 4], // Upper Lengha
                [4, 5, 5, 4], // Mid Lengha (with inner detail/fold to show volume)
                [4, 4, 4, 4], // Lower Lengha (flowing out)
                [0, 6, 6, 0]  // Heels
            ],
            // Saaniya Idle Animation shapes - Adjusted for less suggestive movement
            idleShapes: [
                [ // Frame 0
                    [0, 8, 8, 0],
                    [9, 1, 1, 9],
                    [0, 1, 1, 0],
                    [3, 3, 3, 3],
                    [4, 4, 4, 4],
                    [4, 5, 5, 4],
                    [4, 4, 4, 4],
                    [0, 6, 6, 0]
                ],
                [ // Frame 1 (subtle upper body shift)
                    [0, 8, 8, 0],
                    [9, 1, 1, 9],
                    [0, 1, 1, 0],
                    [4, 3, 3, 4], // Subtle arm/upper body shift
                    [3, 4, 4, 3], // Subtle torso shift
                    [4, 5, 5, 4],
                    [4, 4, 4, 4],
                    [0, 6, 6, 0]
                ]
            ],
            colorMap: {
                0: 'transparent',
                1: '#f0c78c', // Skin tone
                2: '#e5b078', // Face shade / Bindi detail
                3: '#e74c3c', // Choli (Vibrant Red)
                4: '#9b59b6', // Lengha (Royal Purple)
                5: '#7c4b92', // Lengha shade/detail for folds
                6: '#34495e', // Heels (Dark Grey/Black)
                8: '#8B4513', // Hair (Saddle Brown)
                9: '#000000'  // Eyes (black) / Bindi (small black dot)
            },
            animationFrame: 0,
            animationSpeed: 10 // Slower animation for idle
        };

        // Standard Enemy (Ground-based)
        const groundEnemyType = {
            shape: [
                [0, 0, 0, 0],
                [0, 1, 1, 0], // Head/Eyes
                [1, 2, 2, 1], // Body top
                [1, 2, 2, 1], // Body middle
                [1, 1, 1, 1], // Body bottom
                [0, 3, 3, 0], // Legs/Feet
                [0, 0, 0, 0]
            ],
            colorMap: {
                0: 'transparent',
                1: '#8B0000', // Dark Red body
                2: '#FF4500', // Orange-red highlights / eyes
                3: '#5C4033'  // Dark brown feet/base
            },
            width: gridSize,
            height: gridSize
        };

        // Flying Enemy
        const flyingEnemyType = {
            shape: [
                [0, 0, 0, 0],
                [1, 1, 1, 1], // Top wing segment
                [0, 2, 2, 0], // Body/eye
                [1, 1, 1, 1], // Bottom wing segment
                [0, 3, 3, 0], // Tail
                [0, 0, 0, 0]
            ],
            colorMap: {
                0: 'transparent',
                1: '#FFD700', // Gold wings
                2: '#DAA520', // Goldenrod body / shade
                3: '#8B0000'  // Dark Red for eyes/tail tip
            },
            width: gridSize,
            height: gridSize
        };

        // Key definition - More distinctly a key
        const keyType = {
            width: gridSize, // Full tile size
            height: gridSize,
            shape: [
                [0, 0, 1, 1, 0, 0, 0, 0], // Top of the key head
                [0, 1, 1, 1, 1, 0, 0, 0], // Upper key head
                [1, 1, 1, 1, 1, 1, 0, 0], // Larger key head
                [0, 0, 1, 1, 0, 0, 0, 0], // Neck of key
                [0, 0, 1, 0, 0, 0, 0, 0], // Shaft
                [0, 0, 1, 0, 0, 0, 0, 0], // Shaft
                [0, 0, 1, 2, 2, 0, 0, 0], // Key teeth part 1 (extended)
                [0, 0, 1, 2, 0, 0, 0, 0]  // Key teeth part 2
            ],
            colorMap: {
                0: 'transparent',
                1: '#FFD700', // Gold for key body
                2: '#FFA500'  // Orange for key teeth
            }
        };

        // Gate definition (new obstacle type)
        const gateType = {
            width: gridSize,
            height: 2 * gridSize, // 2 tiles tall
            shape: [
                [1, 1, 1, 1],
                [1, 2, 2, 1],
                [1, 2, 2, 1],
                [1, 1, 1, 1],
                [1, 2, 2, 1],
                [1, 2, 2, 1],
                [1, 1, 1, 1]
            ],
            colorMap: {
                1: '#5C4033', // Dark wood/metal frame
                2: '#8B4513'  // Lighter wood/metal bars
            }
        };


        // Enemy constructor function
        function createEnemy(x, y, speed, type = 'ground') {
            const enemyBase = { x, y, dx: speed, dy: 0, animationFrame: 0, animationSpeed: 8 };
            if (type === 'flying') {
                return { ...enemyBase, ...flyingEnemyType, initialY: y, verticalAmplitude: 30, verticalSpeed: 0.05, type: 'flying' };
            }
            return { ...enemyBase, ...groundEnemyType, type: 'ground' };
        }
        let enemies = [];

        // Collectible constructor function
        function createCollectible(x, y) {
            return {
                x: x,
                y: y,
                width: gridSize / 2, // Half tile size for coins
                height: gridSize / 2,
                color: '#f1c40f', // Gold
                collected: false,
                points: 100 // Points per collectible
            };
        }
        let collectibles = [];
        let totalCollectiblesCurrentLevel = 0; // Total points available in current level

        // Key object
        let levelKey = null; // Represents the key in the current level

        // Gate object
        let levelGate = null; // Represents the gate in the current level


        // Cloud definition
        function createCloud(x, y, width, height, speed) {
            return { x, y, width, height, speed, color: '#ecf0f1' }; // Light grey/white
        }
        let clouds = [];

        // Confetti particle definition
        function createConfettiParticle(x, y) {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
            return {
                x: x,
                y: y,
                size: Math.random() * 5 + 3, // Random size between 3 and 8
                dx: (Math.random() - 0.5) * 10, // Horizontal velocity
                dy: (Math.random() - 1) * 10,  // Upward initial velocity
                color: colors[Math.floor(Math.random() * colors.length)],
                lifetime: 60 + Math.random() * 60 // Lifetime in frames (1-2 seconds)
            };
        }
        let confettiParticles = []; // Array to hold confetti particles


        // Game Maps (separated by level)
        const gameMaps = {
            1: [
                // Row 0 (Sky)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                // Row 4 (Higher Platforms)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', 'C', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', ' ', ' ', ' ', 'C', ' ', ' ', ' ', 'C'],
                // Row 5 (Mid-level Platforms/Obstacles)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'O', 'O', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                // Row 6 (More Platforms)
                [' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' '],
                // Row 7 (Main Ground and Gaps)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', 'C', ' ', 'O', 'O', 'O', ' ', ' ', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
                // Row 8 (Obstacles/Ground)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'O', 'O', ' ', ' ', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
                // Row 9 (Bottom Layer - for falling into void)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G']
            ],
            2: [ // Level 2 - More challenging!
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // Flying enemy starts at col 23, moves left
                [' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // Platform with enemy wider
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'O', 'O', 'O', 'O', 'O', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // Obstacle is now 5 blocks wide, 'F' flying enemy removed from here
                [' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', 'C', ' ', ' ', ' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' '], // New platform, new enemy
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'O', 'O', 'O', 'O', 'O', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'G', 'G'], // Taller obstacle after pit, 'O' is 2 tiles tall
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'O', 'O', 'O', 'O', 'O', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', 'G', 'G', 'G', 'G', 'G'],
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G']
            ],
            3: [ // Level 3 - Redesigned from scratch (100x40 map)
                Array(100).fill(' '), // 0
                Array(100).fill(' '), // 1
                Array(100).fill(' '), // 2
                Array(100).fill(' '), // 3
                Array(100).fill(' '), // 4
                Array(100).fill(' '), // 5
                Array(100).fill(' '), // 6
                Array(100).fill(' '), // 7
                Array(100).fill(' '), // 8
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'K', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 9 - KEY
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 10 - Platform for key
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 11 - Flying enemy
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 12 - Higher Platform for Key path
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 13 - Platform below flying enemy
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 14 - Platform near start of key path climb
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 15
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 16

                // Main ground and initial platforms (Rows 17-29)
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'], // 17 - Main starting ground (player spawns here)
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 18 - Padding for player height
                [' ', ' ', ' ', 'C', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 19 - Collectible near start
                [' ', 'P', 'P', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 20 - Platform after start
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 21 - Ground enemy
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'], // 22 - Solid ground
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 23
                // Pit section
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G'], // 24 - Edge of pit
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 25
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'P', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 26 - Pit recovery platform
                ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'], // 27 - Ground after pit

                // Vertical climb to Key path and Princess area
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 28
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 29
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 30
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 31
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 32
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 33
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 34
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 35
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 36
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 37
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], // 38
                Array(100).fill('G') // 39 - Bottommost ground, always solid
            ]
        };
        let currentLevel = 1;
        let gameMap = []; // The game's active map, which can be modified
        let mapWidthTiles;
        let mapHeightTiles;
        let totalMapPixelWidth;
        let totalMapPixelHeight;

        // Game state variables
        let gameEnded = false; // When woman is rescued
        let gameOver = false; // When man dies
        let score = 0;
        let deathCount = 0; // New: Death counter
        let hasKey = false; // New: For Level 3
        let unlockedLevels = 1; // New: Tracks unlocked levels

        let messageText = ""; // Changed initial message to empty
        let messageTimer = 0; // Changed initial timer to 0
        let initialMessageActive = false; // Changed to false by default

        // DOM elements
        let scoreDisplay = document.getElementById('scoreDisplay');
        let levelDisplay = document.getElementById('levelDisplay');
        let deathCounter = document.getElementById('deathCounter'); // New: Death counter display
        let restartButton = document.getElementById('restartButton');
        let nextLevelButton = document.getElementById('nextLevelButton');
        let playAgainButton = document.getElementById('playAgainButton'); // New button
        let levelSelector = document.getElementById('levelSelector');
        let levelButtons = {}; // To store references to level buttons

        // Keyboard input handling
        const keys = {
            ArrowLeft: false, ArrowRight: false, ArrowUp: false,
            a: false, d: false, w: false
        };

        // Event listeners for keyboard
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                if (initialMessageActive) { // Allow any input to dismiss initial message
                    initialMessageActive = false;
                    messageTimer = 0;
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        // Touch controls setup
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');
        
        restartButton.addEventListener('click', resetGame);
        nextLevelButton.addEventListener('click', () => {
            currentLevel++;
            resetGame();
        });
        playAgainButton.addEventListener('click', () => {
            currentLevel = 1; // Reset to level 1
            deathCount = 0; // Reset deaths for a new game
            unlockedLevels = 1; // Reset unlocked levels
            resetGame();
        });

        // Initialize level selector buttons
        for (let i = 1; i <= Object.keys(gameMaps).length; i++) {
            const btn = document.getElementById(`level${i}Button`);
            levelButtons[i] = btn;
            btn.addEventListener('click', (e) => {
                if (!btn.classList.contains('disabled')) {
                    currentLevel = parseInt(e.target.dataset.level);
                    resetGame();
                }
            });
        }

        function handleButtonPress(key, isPressed) {
            if (keys.hasOwnProperty(key)) {
                keys[key] = isPressed;
                if (initialMessageActive) { // Allow any input to dismiss initial message
                    initialMessageActive = false;
                    messageTimer = 0;
                }
            }
        }

        // Attach touch and mouse events to buttons
        [
            { button: leftButton, key: 'ArrowLeft' },
            { button: rightButton, key: 'ArrowRight' },
            { button: jumpButton, key: 'ArrowUp' }
        ].forEach(({ button, key }) => {
            // Mouse events
            button.addEventListener('mousedown', (e) => { e.preventDefault(); handleButtonPress(key, true); });
            button.addEventListener('mouseup', () => handleButtonPress(key, false));
            button.addEventListener('mouseleave', () => handleButtonPress(key, false)); // Release if mouse leaves button
            // Touch events
            button.addEventListener('touchstart', (e) => { e.preventDefault(); handleButtonPress(key, true); }, { passive: false });
            button.addEventListener('touchend', () => handleButtonPress(key, false));
            button.addEventListener('touchcancel', () => handleButtonPress(key, false));
        });

        // Function to check for intersection between two rectangles
        function intersectRect(r1, r2) {
            return !(r2.x >= r1.x + r1.width ||
                     r2.x + r2.width <= r1.x ||
                     r2.y >= r1.y + r1.height ||
                     r2.y + r2.height <= r1.y);
        }

        // Function to get the bounding box of a tile
        function getTileBoundingBox(tileX, tileY) {
            return {
                x: tileX * gridSize,
                y: tileY * gridSize,
                width: gridSize,
                height: gridSize
            };
        }


        // Function to resize canvas and initialize game positions
        function resizeGame() {
            const gameContainer = document.querySelector('.game-container');
            const style = getComputedStyle(gameContainer);
            const containerPaddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
            const containerPaddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);

            const headerHeight = document.querySelector('h1').offsetHeight;
            const gameInfoHeight = document.getElementById('scoreDisplay').parentElement.offsetHeight;
            const controlsHeight = document.querySelector('.controls').offsetHeight;
            const restartButtonHeight = restartButton.classList.contains('hidden') ? 0 : restartButton.offsetHeight;
            const nextLevelButtonHeight = nextLevelButton.classList.contains('hidden') ? 0 : nextLevelButton.offsetHeight;
            const playAgainButtonHeight = playAgainButton.classList.contains('hidden') ? 0 : playAgainButton.offsetHeight;
            const levelSelectorHeight = levelSelector.offsetHeight; // Get the height of the level selector div

            let uiElementsTotalHeight = headerHeight + gameInfoHeight + controlsHeight + restartButtonHeight + nextLevelButtonHeight + playAgainButtonHeight + levelSelectorHeight + containerPaddingY;

            uiElementsTotalHeight += 20; // Extra buffer for vertical space

            let availableWidth = gameContainer.clientWidth - containerPaddingX;
            let availableHeight = window.innerHeight - uiElementsTotalHeight;

            let targetWidth = availableWidth;
            let targetHeight = (targetWidth / 16) * 9;

            if (targetHeight > availableHeight) {
                targetHeight = availableHeight;
                targetWidth = (targetHeight / 9) * 16;
            }

            const minCanvasWidth = gridSize * 15;
            const minCanvasHeight = gridSize * 9;

            canvas.width = Math.max(minCanvasWidth, Math.floor(targetWidth / gridSize) * gridSize);
            canvas.height = Math.max(minCanvasHeight, Math.floor(targetHeight / gridSize) * gridSize);

            canvas.style.width = '100%';
            canvas.style.height = 'auto';

            // Camera Y will be fixed to the bottom of the map, only scrolls when map is taller than canvas
            cameraY = totalMapPixelHeight - canvas.height;
            if (cameraY < 0) cameraY = 0; // If map is shorter than canvas, cameraY is 0 (top of map visible)


            // Initial player and woman placement (absolute world coordinates)
            // Default for Level 1 & 2
            man.x = man.initialX;
            man.y = (7 * gridSize) - man.height; // Placed on main ground (row 7)

            woman.x = (mapWidthTiles - 5) * gridSize; // 5 tiles from the right edge
            woman.y = (7 * gridSize) - woman.height; // On same main ground as man

            // Specific adjustments for Level 3
            if (currentLevel === 3) {
                // Man starts at (col 2, row 17) in the new Level 3 map
                man.x = 2 * gridSize;
                man.y = (17 * gridSize) - man.height; // Positioned on ground at row 17

                // Woman at (col 91, row 26) in new Level 3 map, behind the gate
                woman.x = 91 * gridSize;
                woman.y = (26 * gridSize) - woman.height; // Positioned on ground at row 26

                if (levelGate) {
                    // Gate is at (col 90, row 26) in the new Level 3 map (it's 2 tiles tall, so it occupies 26 and 27)
                    levelGate.x = 90 * gridSize;
                    levelGate.y = 26 * gridSize; // Top of the gate (row 26)
                }
            }


            drawGame(); // Initial draw after resize and placement
        }

        // Function to update level selector button states
        function updateLevelSelector() {
            for (let i = 1; i <= Object.keys(gameMaps).length; i++) {
                const btn = levelButtons[i];
                if (btn) {
                    if (i <= unlockedLevels) {
                        btn.classList.remove('disabled');
                    } else {
                        btn.classList.add('disabled');
                    }
                    if (i === currentLevel) {
                        btn.classList.add('current-level');
                    } else {
                        btn.classList.remove('current-level');
                    }
                }
            }
        }

        // Initialize entities (enemies, collectibles, clouds) based on the map
        function initializeEntities() {
            enemies = [];
            collectibles = [];
            clouds = []; // Reset clouds for new game
            confettiParticles = []; // Clear any lingering confetti
            hasKey = false; // Reset key state for each level
            levelKey = null; // Ensure key is nullified if not present
            levelGate = null; // Ensure gate is nullified if not present

            // Add some initial clouds (absolute map coordinates, will be drawn with parallax)
            clouds.push(createCloud(100, 50, 100, 40, 0.5));
            clouds.push(createCloud(500, 100, 150, 60, 0.3));
            clouds.push(createCloud(900, 70, 80, 30, 0.6));
            clouds.push(createCloud(200, 150, 120, 50, 0.4));

            // Use the current level's map data
            const currentMapData = gameMaps[currentLevel];
            mapWidthTiles = currentMapData[0].length;
            mapHeightTiles = currentMapData.length;
            totalMapPixelWidth = mapWidthTiles * gridSize;
            totalMapPixelHeight = mapHeightTiles * gridSize;


            // Create a deep copy of the original map for the current game session
            for(let i=0; i<currentMapData.length; i++) {
                gameMap[i] = [...currentMapData[i]];
            }

            totalCollectiblesCurrentLevel = 0; // Reset for new level

            for (let row = 0; row < mapHeightTiles; row++) {
                for (let col = 0; col < mapWidthTiles; col++) {
                    const tileType = gameMap[row][col];
                    const px = col * gridSize;
                    const py = row * gridSize;

                    if (tileType === 'E') {
                        enemies.push(createEnemy(px, py + gridSize - (groundEnemyType.height), 2, 'ground'));
                        gameMap[row][col] = ' '; // Clear spawn point
                    } else if (tileType === 'F') {
                        // Flying enemy position needs to be adjusted based on its height
                        enemies.push(createEnemy(px, py + gridSize / 2, -1.5, 'flying')); // Initial dx is -1.5 (left)
                        gameMap[row][col] = ' '; // Clear spawn point
                    } else if (tileType === 'C') {
                        collectibles.push(createCollectible(px + gridSize / 4, py + gridSize / 4)); // Center coin in tile
                        totalCollectiblesCurrentLevel += 100; // Add to total
                        gameMap[row][col] = ' '; // Clear collectible
                    } else if (tileType === 'K') { // Initialize Key
                        levelKey = {
                            x: px + (gridSize - keyType.width) / 2, // Center key horizontally within a grid
                            y: py + (gridSize - keyType.height) / 2, // Center key vertically within a grid
                            width: keyType.width,
                            height: keyType.height,
                            shape: keyType.shape,
                            colorMap: keyType.colorMap,
                            collected: false
                        };
                        gameMap[row][col] = ' '; // Clear key spawn
                    } else if (tileType === 'X') { // Initialize Gate
                        levelGate = {
                            x: px,
                            y: py,
                            width: gateType.width,
                            height: gateType.height,
                            shape: gateType.shape,
                            colorMap: gateType.colorMap,
                            isOpen: false
                        };
                        // The 'X' remains on the map as a blocking tile until opened
                    }
                }
            }
        }

        // Get tile type at specific pixel coordinates
        function getTileAtPixel(px, py) {
            const tileX = Math.floor(px / gridSize);
            const tileY = Math.floor(py / gridSize);

            if (tileX >= 0 && tileX < mapWidthTiles && tileY >= 0 && tileY < mapHeightTiles) {
                return gameMap[tileY][tileX];
            }
            return ' '; // Treat out-of-bounds as empty space
        }

        // Draw a pixel art character (man/woman/enemy/key/gate)
        function drawCharacter(character, cameraX, isWalking = false, isIdle = false) {
            const drawX = character.x - cameraX;
            const drawY = character.y - cameraY;

            // Ensure character.shape is an array and has at least one row
            if (!character.shape || character.shape.length === 0 || character.shape[0].length === 0) {
                console.warn("Character shape is invalid:", character);
                return;
            }

            const charPixelDrawSizeX = character.width / character.shape[0].length;
            const charPixelDrawSizeY = character.height / character.shape.length;

            let currentShape = character.shape;

            // Apply walking animation for man
            if (isWalking && character === man) {
                const step = Math.floor(character.animationFrame / character.animationSpeed) % man.walkingShape.length;
                currentShape = man.walkingShape; // For man, walkingShape is the animation frame
            } else if (character === man) {
                currentShape = man.shape; // Default standing shape
            }

            // Apply idle animation for woman
            if (isIdle && character === woman) {
                const step = Math.floor(gameFrameCounter / character.animationSpeed) % character.idleShapes.length;
                currentShape = character.idleShapes[step];
            }

            // Apply hit animation (flashing) for the man
            if (character === man && man.isHit && (Math.floor(man.hitTimer / 5) % 2 === 0)) {
                return; // Skip drawing to create a flashing effect
            }

            currentShape.forEach((row, rowIndex) => {
                row.forEach((pixelType, colIndex) => {
                    const color = character.colorMap[pixelType];
                    if (color && color !== 'transparent') {
                        ctx.fillStyle = color;
                        ctx.fillRect(
                            drawX + colIndex * charPixelDrawSizeX,
                            drawY + rowIndex * charPixelDrawSizeY,
                            charPixelDrawSizeX,
                            charPixelDrawSizeY
                        );
                    }
                });
            });
        }

        // Draw the game map
        function drawMap(cameraX, cameraY) {
            const startCol = Math.floor(cameraX / gridSize);
            const endCol = startCol + Math.ceil(canvas.width / gridSize) + 1;

            for (let row = 0; row < mapHeightTiles; row++) {
                for (let col = startCol; col < endCol; col++) {
                    const tileType = getTileAtPixel(col * gridSize, row * gridSize);
                    const drawX = col * gridSize - cameraX;
                    const drawY = row * gridSize - cameraY;

                    if (tileType === 'G') {
                        ctx.fillStyle = '#654321'; // Brown for ground
                        ctx.fillRect(drawX, drawY, gridSize, gridSize);
                        // Add some grass tops
                        ctx.fillStyle = '#228B22'; // Forest green
                        ctx.fillRect(drawX, drawY, gridSize, gridSize / 4);
                    } else if (tileType === 'O') {
                        ctx.fillStyle = '#7f8c8d'; // Grey for obstacles (rocks/bricks)
                        ctx.fillRect(drawX, drawY, gridSize, gridSize);
                        // Add simple brick lines for castle-like appearance
                        ctx.strokeStyle = '#525e60';
                        ctx.lineWidth = 2;
                        // Horizontal lines
                        ctx.beginPath();
                        ctx.moveTo(drawX, drawY + gridSize / 4);
                        ctx.lineTo(drawX + gridSize, drawY + gridSize / 4);
                        ctx.moveTo(drawX, drawY + gridSize / 2);
                        ctx.lineTo(drawX + gridSize, drawY + gridSize / 2);
                        ctx.moveTo(drawX, drawY + (3 * gridSize) / 4);
                        ctx.lineTo(drawX + gridSize, drawY + (3 * gridSize) / 4);
                        ctx.stroke();
                        // Vertical lines (staggered)
                        ctx.beginPath();
                        ctx.moveTo(drawX + gridSize / 2, drawY);
                        ctx.lineTo(drawX + gridSize / 2, drawY + gridSize / 4);
                        ctx.moveTo(drawX + gridSize / 4, drawY + gridSize / 2);
                        ctx.lineTo(drawX + gridSize / 4, drawY + (3 * gridSize) / 4);
                        ctx.moveTo(drawX + (3 * gridSize) / 4, drawY + gridSize / 4);
                        ctx.lineTo(drawX + (3 * gridSize) / 4, drawY + gridSize / 2);
                        ctx.moveTo(drawX + gridSize / 2, drawY + (3 * gridSize) / 4);
                        ctx.lineTo(drawX + gridSize / 2, drawY + gridSize);
                        ctx.stroke();

                    } else if (tileType === 'P') {
                        ctx.fillStyle = '#27ae60'; // Green for platforms
                        ctx.fillRect(drawX, drawY, gridSize, gridSize / 2); // Thinner platform
                        ctx.fillStyle = '#1e8449'; // Darker green underside
                        ctx.fillRect(drawX, drawY + gridSize / 2, gridSize, gridSize / 2);
                    } else if (tileType === 'X' && levelGate && !levelGate.isOpen) { // Draw gate if it's there and not open
                        drawCharacter(levelGate, cameraX);
                    }
                }
            }
        }

        // Draw the castle background elements
        function drawBackground(cameraX, cameraY) {
            const castleColor = '#a9a9a9';
            const windowColor = '#fdfd96';
            const turretColor = '#808080';
            const battlementColor = '#696969';
            const flagColor = '#e74c3c';
            const deepGroundColor = '#3a3a3a'; // Slightly lighter dark ground

            // 1. Fill entire canvas with deep ground color (as a base layer)
            ctx.fillStyle = deepGroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate the absolute Y coordinate of the main ground level in the world
            // (assuming row 7 is where the main ground starts in the map data, adjust for Level 3 if needed)
            let groundRefRow = 7; // Default for level 1 & 2
            if (currentLevel === 3) {
                groundRefRow = 26; // Main ground for Level 3 (where player starts, and gate is)
            }
            const mapGroundAbsoluteY = groundRefRow * gridSize;


            // 2. Draw Sky (will overlay part of the deep ground)
            ctx.fillStyle = '#7da5d9'; // Sky blue
            // Sky should extend down to the 'ground' level in the background
            const castleTopRelativeToGround = 3 * gridSize; // How many grid units the castle wall extends UP from the map ground
            const skyEndDrawY = mapGroundAbsoluteY - castleTopRelativeToGround - (cameraY * 0.5); // Apply parallax
            ctx.fillRect(0, 0, canvas.width, Math.max(0, skyEndDrawY));


            // Parallax offset for background elements
            const parallaxOffsetX = cameraX * 0.5;
            const parallaxOffsetY = cameraY * 0.5;

            const backgroundRepeatWidth = gridSize * 15;

            const startDrawX = - (parallaxOffsetX % backgroundRepeatWidth);
            const numRepeats = Math.ceil((canvas.width + backgroundRepeatWidth) / backgroundRepeatWidth) + 1;

            // Define how much the castle extends *below* the visible map ground
            const castleFoundationDepth = 15 * gridSize; // Increased foundation depth to cover entire map height

            for (let i = 0; i < numRepeats + 1; i++) {
                const currentSectionX = startDrawX + i * backgroundRepeatWidth;

                // Define castle base drawing Y relative to mapGroundAbsoluteY
                const castleWallDrawY = mapGroundAbsoluteY - castleTopRelativeToGround - parallaxOffsetY;

                // --- Base Wall (extended downwards) ---
                ctx.fillStyle = castleColor;
                ctx.fillRect(currentSectionX, castleWallDrawY, gridSize * 15, castleTopRelativeToGround + castleFoundationDepth);

                // --- Main Towers (Taller) ---
                const mainTurretHeight = 4 * gridSize;
                const mainTurretDrawY = castleWallDrawY - mainTurretHeight;
                ctx.fillStyle = turretColor;
                ctx.fillRect(currentSectionX + 1 * gridSize, mainTurretDrawY, 2 * gridSize, mainTurretHeight);
                ctx.fillRect(currentSectionX + 12 * gridSize, mainTurretDrawY, 2 * gridSize, mainTurretHeight);

                // --- Smaller Tower ---
                const shortTurretHeight = 2 * gridSize;
                const shortTurretDrawY = castleWallDrawY - shortTurretHeight;
                ctx.fillStyle = turretColor;
                ctx.fillRect(currentSectionX + 6 * gridSize, shortTurretDrawY, 2 * gridSize, shortTurretHeight);

                // --- Battlement details ---
                ctx.fillStyle = battlementColor;
                for (let j = 0; j < 15; j++) {
                    if (j % 2 === 0) {
                        ctx.fillRect(currentSectionX + j * gridSize, castleWallDrawY, gridSize, gridSize / 2);
                    }
                }
                ctx.fillRect(currentSectionX + 1 * gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);
                ctx.fillRect(currentSectionX + 1 * gridSize + gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);
                ctx.fillRect(currentSectionX + 12 * gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);
                ctx.fillRect(currentSectionX + 12 * gridSize + gridSize, mainTurretDrawY - (gridSize / 2), gridSize / 2, gridSize / 2);

                // --- Windows ---
                ctx.fillStyle = windowColor;
                ctx.fillRect(currentSectionX + 3 * gridSize, castleWallDrawY + (0.5 * gridSize), gridSize, gridSize);
                ctx.fillRect(currentSectionX + 9 * gridSize, castleWallDrawY + (0.5 * gridSize), gridSize, gridSize);
                ctx.fillRect(currentSectionX + 1.5 * gridSize, mainTurretDrawY + gridSize, gridSize, gridSize / 2);
                ctx.fillRect(currentSectionX + 12.5 * gridSize, mainTurretDrawY + gridSize, gridSize, gridSize / 2);
                ctx.fillStyle = windowColor;
                ctx.fillRect(currentSectionX + 6.5 * gridSize, shortTurretDrawY + gridSize / 2, gridSize, gridSize / 2);
                ctx.fillRect(currentSectionX + 6.5 * gridSize + gridSize / 4, shortTurretDrawY + gridSize, gridSize / 2, gridSize / 2);

                // --- Flag ---
                ctx.fillStyle = flagColor;
                ctx.fillRect(currentSectionX + 1.5 * gridSize + gridSize / 2 - 2, mainTurretDrawY - gridSize - 10, 4, gridSize + 10);
                ctx.fillRect(currentSectionX + 1.5 * gridSize + gridSize / 2 - 2, mainTurretDrawY - gridSize - 10, gridSize, gridSize / 2);
            }

            // Draw clouds
            clouds.forEach(cloud => {
                ctx.fillStyle = cloud.color;
                ctx.beginPath();
                ctx.arc(cloud.x - parallaxOffsetX + cloud.width * 0.2, cloud.y - parallaxOffsetY + cloud.height * 0.5, cloud.height * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x - parallaxOffsetX + cloud.width * 0.5, cloud.y - parallaxOffsetY + cloud.height * 0.3, cloud.height * 0.7, 0, Math.PI * 2);
                ctx.arc(cloud.x - parallaxOffsetX + cloud.width * 0.8, cloud.y - parallaxOffsetY + cloud.height * 0.5, cloud.height * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Helper function to wrap text into multiple lines based on max width
        function getWrappedTextLines(context, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0] || '';

            if (words.length === 0) return [""];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + ' ' + word;
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxWidth && i > 0) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Function to draw overlay text on the canvas, now supports multiple lines
        function drawOverlayMessage(message) {
            const maxFontSize = 48;
            const minFontSize = 24;
            let fontSize = Math.min(maxFontSize, Math.max(minFontSize, canvas.width * 0.06));
            ctx.font = `bold ${fontSize}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;

            const segmentsByExplicitNewline = message.split('\n');
            let finalLines = [];
            const maxWidth = canvas.width * 0.8;

            segmentsByExplicitNewline.forEach(segment => {
                const wrappedLinesInSegment = getWrappedTextLines(ctx, segment, maxWidth);
                finalLines = finalLines.concat(wrappedLinesInSegment);
            });
            
            const lineHeight = fontSize + 12;
            const totalTextHeight = finalLines.length * lineHeight;
            const startY = (canvas.height / 2) - (totalTextHeight / 2) + (lineHeight / 2);

            const x = canvas.width / 2;

            finalLines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                ctx.strokeText(line, x, y);
                ctx.fillText(line, x, y);
            });
        }

        // Function to spawn confetti particles
        function spawnConfetti() {
            confettiParticles = [];
            const spawnX = woman.x + woman.width / 2;
            const spawnY = woman.y + woman.height / 2;

            for (let i = 0; i < 100; i++) {
                confettiParticles.push(createConfettiParticle(spawnX, spawnY));
            }
        }


        // Update game logic (physics, movement, collisions)
        function updateGame() {
            // Manage initial message display
            if (initialMessageActive && messageTimer > 0) {
                messageTimer--;
                // Message will disappear when timer runs out or any key/button is pressed
            } else if (messageTimer <= 0 && initialMessageActive) {
                initialMessageActive = false; // Turn off initial message after timer
            }

            if (!gameEnded && !gameOver) {
                man.dy += GRAVITY;

                let movedHorizontally = false;
                man.dx = 0;
                if (keys.ArrowLeft || keys.a) {
                    man.dx = -PLAYER_HORIZONTAL_SPEED;
                    movedHorizontally = true;
                }
                if (keys.ArrowRight || keys.d) {
                    man.dx = PLAYER_HORIZONTAL_SPEED;
                    movedHorizontally = true;
                }

                let nextManRectX = {
                    x: man.x + man.dx,
                    y: man.y,
                    width: man.width,
                    height: man.height
                };

                const x1 = Math.floor(nextManRectX.x / gridSize);
                const x2 = Math.ceil((nextManRectX.x + nextManRectX.width) / gridSize);
                const y1 = Math.floor(nextManRectX.y / gridSize);
                const y2 = Math.ceil((nextManRectX.y + nextManRectX.height) / gridSize);

                for (let row = y1; row < y2; row++) {
                    for (let col = x1; col < x2; col++) {
                        const tileType = getTileAtPixel(col * gridSize, row * gridSize);
                        if (['G', 'O', 'P'].includes(tileType) || (tileType === 'X' && levelGate && !levelGate.isOpen)) { // Man can't pass closed gate
                            const tileRect = getTileBoundingBox(col, row);
                            if (intersectRect(nextManRectX, tileRect)) {
                                if (man.dx > 0) {
                                    man.x = tileRect.x - man.width;
                                } else if (man.dx < 0) {
                                    man.x = tileRect.x + tileRect.width;
                                }
                                man.dx = 0;
                                break;
                            }
                        }
                    }
                }
                if (man.dx !== 0) {
                    man.x += man.dx;
                }

                // Update man's direction for drawing
                if (man.dx < 0) man.currentDirection = 'left';
                else if (man.dx > 0) man.currentDirection = 'right';

                if (movedHorizontally && man.onGround) {
                    man.animationFrame++;
                } else {
                    man.animationFrame = 0;
                }

                let nextManRectY = {
                    x: man.x,
                    y: man.y + man.dy,
                    width: man.width,
                    height: man.height
                };

                man.onGround = false;

                const vy1 = Math.floor(nextManRectY.y / gridSize);
                const vy2 = Math.ceil((nextManRectY.y + nextManRectY.height) / gridSize);
                const vx1 = Math.floor(nextManRectY.x / gridSize);
                const vx2 = Math.ceil((nextManRectY.x + nextManRectY.width) / gridSize);

                for (let row = vy1; row < vy2; row++) {
                    for (let col = vx1; col < vx2; col++) {
                        const tileType = getTileAtPixel(col * gridSize, row * gridSize);
                        if (['G', 'O', 'P'].includes(tileType) || (tileType === 'X' && levelGate && !levelGate.isOpen)) { // Man can't pass closed gate
                            const tileRect = getTileBoundingBox(col, row);
                            if (intersectRect(nextManRectY, tileRect)) {
                                if (man.dy > 0) {
                                    man.y = tileRect.y - man.height;
                                    man.onGround = true;
                                } else if (man.dy < 0) {
                                    man.y = tileRect.y + tileRect.height;
                                }
                                man.dy = 0;
                                break;
                            }
                        }
                    }
                }
                if (man.dy !== 0) {
                    man.y += man.dy;
                }

                if (man.y > totalMapPixelHeight + (2 * gridSize)) {
                    gameOver = true;
                    deathCount++; // Increment death count
                    deathCounter.textContent = `Deaths: ${deathCount}`;
                    messageText = "Game Over!\nYou fell into the void!";
                    restartButton.classList.remove('hidden');
                    nextLevelButton.classList.add('hidden');
                    playAgainButton.classList.add('hidden'); // Hide Play Again
                    return;
                }

                if ((keys.ArrowUp || keys.w) && man.onGround) {
                    man.dy = JUMP_STRENGTH;
                    man.onGround = false;
                }

                enemies.forEach(enemy => {
                    if (enemy.type === 'ground') {
                        enemy.dy += GRAVITY;
                        enemy.y += enemy.dy;

                        let nextEnemyY = enemy.y + enemy.dy;
                        const enemyBottomTileRow = Math.floor((nextEnemyY + enemy.height) / gridSize);
                        const enemyLeftCol = Math.floor(enemy.x / gridSize);
                        const enemyRightCol = Math.floor((enemy.x + enemy.width - 1) / gridSize);

                        let enemyOnGround = false;
                        for (let col = enemyLeftCol; col <= enemyRightCol; col++) {
                            const tileType = getTileAtPixel(col * gridSize, enemyBottomTileRow * gridSize);
                            if (['G', 'O', 'P'].includes(tileType)) {
                                const tileRect = getTileBoundingBox(col, enemyBottomTileRow);
                                if (intersectRect({ x: enemy.x, y: nextEnemyY, width: enemy.width, height: enemy.height }, tileRect)) {
                                    enemy.y = tileRect.y - enemy.height;
                                    enemy.dy = 0;
                                    enemyOnGround = true;
                                    break;
                                }
                            }
                        }

                        enemy.x += enemy.dx;

                        let turnAround = false;
                        let checkX_wall_current = enemy.dx > 0 ? enemy.x + enemy.width : enemy.x;
                        let wallTile_current = getTileAtPixel(checkX_wall_current, enemy.y + enemy.height / 2);
                        if (['G', 'O', 'P'].includes(wallTile_current)) {
                            turnAround = true;
                        }

                        let checkX_ledge = enemy.dx > 0 ? enemy.x + enemy.width + 1 : enemy.x - 1;
                        let checkY_ledge = enemy.y + enemy.height + 1;
                        let ledgeTile = getTileAtPixel(checkX_ledge, checkY_ledge);

                        if (enemyOnGround && !['G', 'O', 'P'].includes(ledgeTile)) {
                            turnAround = true;
                        }

                        if (enemy.x < 0 || enemy.x + enemy.width > totalMapPixelWidth) {
                            turnAround = true;
                        }

                        // Level 1 specific enemy patrol (turn when reaching Saaniya's initial X)
                        if (currentLevel === 1) {
                            // Enemy spawns around col 24, woman at col 35. Enemy should patrol right from spawn, then turn back.
                            const patrolLeftBound = 24 * gridSize; // Enemy spawn X
                            const patrolRightBound = woman.x; // Woman's X coordinate

                            if (enemy.dx > 0 && enemy.x + enemy.width >= patrolRightBound) {
                                turnAround = true;
                            } else if (enemy.dx < 0 && enemy.x <= patrolLeftBound) {
                                turnAround = true;
                            }
                        }


                        if (turnAround) {
                            enemy.dx *= -1;
                        }
                    } else if (enemy.type === 'flying') {
                        enemy.y = enemy.initialY + Math.sin(gameFrameCounter * enemy.verticalSpeed) * enemy.verticalAmplitude;
                        enemy.x += enemy.dx;

                        // Reverse horizontal direction if hitting map boundaries
                        if (enemy.x < 0 || enemy.x + enemy.width > totalMapPixelWidth) {
                            enemy.dx *= -1;
                        }
                    }
                });

                enemies.forEach(enemy => {
                    if (!man.isHit &&
                        man.x < enemy.x + enemy.width &&
                        man.x + man.width > enemy.x &&
                        man.y < enemy.y + enemy.height &&
                        man.y + man.height > enemy.y
                    ) {
                        gameOver = true;
                        deathCount++; // Increment death count
                        deathCounter.textContent = `Deaths: ${deathCount}`;
                        messageText = "Game Over!\nYou were caught by an enemy!";
                        restartButton.classList.remove('hidden');
                        nextLevelButton.classList.add('hidden');
                        playAgainButton.classList.add('hidden'); // Hide Play Again
                    }
                });

                collectibles.forEach(collectible => {
                    if (!collectible.collected &&
                        man.x < collectible.x + collectible.width &&
                        man.x + man.width > collectible.x &&
                        man.y < collectible.y + collectible.height &&
                        man.y + man.height > collectible.y
                    ) {
                        collectible.collected = true;
                        score += collectible.points;
                        scoreDisplay.textContent = `Score: ${score}/${totalCollectiblesCurrentLevel}`;
                    }
                });

                // Check for Key collection
                if (levelKey && !levelKey.collected) {
                    if (intersectRect(man, levelKey)) {
                        levelKey.collected = true;
                        hasKey = true;
                        messageText = "You got the key!";
                        messageTimer = 90; // Show message for 1.5 seconds
                        initialMessageActive = true; // Ensure message appears
                    }
                }

                // Check for rescue collision
                checkRescueCollision();
            }

            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x - cameraX > canvas.width + cloud.width) {
                    cloud.x = cameraX - cloud.width - (Math.random() * 200);
                    cloud.y = Math.random() * (canvas.height / 3);
                }
            });

            confettiParticles = confettiParticles.filter(p => {
                p.dy += GRAVITY * 0.5;
                p.x += p.dx;
                p.y += p.dy;
                p.lifetime--;
                return p.lifetime > 0;
            });

            cameraX = man.x - canvas.width / 2 + man.width / 2;
            cameraX = Math.max(0, Math.min(cameraX, totalMapPixelWidth - canvas.width));
            
            cameraY = man.y - (canvas.height / 2) + (man.height / 2);
            cameraY = Math.max(0, Math.min(cameraY, totalMapPixelHeight - canvas.height));
            if (cameraY < 0) cameraY = 0;
        }

        // Check if man has rescued the woman
        function checkRescueCollision() {
            if (
                man.x < woman.x + woman.width &&
                man.x + man.width > woman.x &&
                man.y < woman.y + woman.height &&
                man.y + man.height > woman.y
            ) {
                if (currentLevel === 3 && levelGate && !levelGate.isOpen) {
                    if (!hasKey) {
                        // This message should always appear when the player reaches the locked gate without the key
                        messageText = "Saaniya is trapped!\nFind the key to open the gate!";
                        messageTimer = 120; // Show for 2 seconds
                        initialMessageActive = true; // Keep message active for a duration
                        return; // Prevent level end
                    } else {
                        levelGate.isOpen = true; // Open the gate
                        // Remove the gate tiles from the game map for collision and drawing
                        const gateCol = Math.floor(levelGate.x / gridSize);
                        const gateTopRow = Math.floor(levelGate.y / gridSize); // Top part of the 2-tile high gate
                        
                        if (gameMap[gateTopRow] && gameMap[gateTopRow][gateCol] === 'X') {
                            gameMap[gateTopRow][gateCol] = ' '; // Clear the top part of the gate
                        }
                        const gateBottomRow = gateTopRow + 1; // Bottom part of the 2-tile high gate
                        if (gameMap[gateBottomRow] && gameMap[gateBottomRow][gateCol] === 'X') {
                            gameMap[gateBottomRow][gateCol] = ' '; // Corrected: use gateCol
                        }

                        messageText = "The gate is open!";
                        messageTimer = 90;
                        initialMessageActive = true;
                    }
                }

                // If it's not level 3, or if it's level 3 and the gate is now open
                if (!gameEnded) {
                    spawnConfetti();
                }
                gameEnded = true;
                
                // Unlock next level logic
                unlockedLevels = Math.max(unlockedLevels, currentLevel + 1);
                updateLevelSelector(); // Update button states

                if (currentLevel < Object.keys(gameMaps).length) {
                    messageText = `Level ${currentLevel} Complete!\nPress 'Next Level' to continue.`;
                    nextLevelButton.classList.remove('hidden');
                    restartButton.classList.add('hidden');
                    playAgainButton.classList.add('hidden');
                } else {
                    messageText = "You rescued her!\nAll levels complete!\nWant to play again?";
                    nextLevelButton.classList.add('hidden');
                    restartButton.classList.add('hidden'); // Hide restart
                    playAgainButton.classList.remove('hidden'); // Show Play Again
                }
            }
        }

        // Draw everything on the canvas
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            drawBackground(cameraX, cameraY); // Pass cameraY
            drawMap(cameraX, cameraY); // Pass cameraY

            // Draw enemies
            enemies.forEach(enemy => {
                drawCharacter(enemy, cameraX);
            });

            // Draw collectibles
            collectibles.forEach(collectible => {
                if (!collectible.collected) {
                    ctx.fillStyle = collectible.color;
                    ctx.beginPath();
                    ctx.arc(collectible.x - cameraX + collectible.width / 2, collectible.y - cameraY + collectible.height / 2, collectible.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#e67e22';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });

            // Draw Key if it exists and is not collected
            if (levelKey && !levelKey.collected) {
                drawCharacter(levelKey, cameraX);
            }

            // Draw Haroon
            drawCharacter(man, cameraX, man.dx !== 0, false); // Pass true if walking, false for idle

            // Draw Saaniya
            drawCharacter(woman, cameraX, false, true); // Always true for idle animation

            // Draw confetti particles
            confettiParticles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - cameraX, p.y - cameraY, p.size, p.size);
            });

            // Draw overlay messages if game is ended or over OR if it's the initial message
            if (gameEnded || gameOver || initialMessageActive) {
                drawOverlayMessage(messageText);
            }
        }

        // Reset game state for restart or next level
        function resetGame() {
            // Cancel any existing game loop to prevent speed increase
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            gameEnded = false;
            gameOver = false;
            score = 0; // Reset score for new game
            
            levelDisplay.textContent = `Level: ${currentLevel}`;
            deathCounter.textContent = `Deaths: ${deathCount}`; // Update death counter display
            
            // Set initial message only for level 1 or specific level 3 scenario
            if (currentLevel === 1) {
                messageText = "Use Arrow Keys (Left/Right/Up)\nor Touch Controls to move and jump!";
                messageTimer = 180;
                initialMessageActive = true;
            } else if (currentLevel === 3 && !hasKey) { // Added condition for Level 3
                // Show "Saaniya is trapped" at the start of Level 3 IF key is not yet obtained
                messageText = "Saaniya is trapped!\nFind the key to open the gate!";
                messageTimer = 180; // Show for a good duration
                initialMessageActive = true;
            } else {
                messageText = "";
                messageTimer = 0;
                initialMessageActive = false;
            }

            restartButton.classList.add('hidden');
            nextLevelButton.classList.add('hidden');
            playAgainButton.classList.add('hidden');

            initializeEntities(); // This will recalculate totalCollectiblesCurrentLevel
            scoreDisplay.textContent = `Score: ${score}/${totalCollectiblesCurrentLevel}`; // Update with new total
            
            resizeGame();
            man.dx = 0; man.dy = 0;
            man.onGround = false;
            man.isHit = false;
            man.hitTimer = 0;
            confettiParticles = [];
            gameFrameCounter = 0;

            updateLevelSelector(); // Ensure level selector buttons are updated

            // Start a new game loop
            gameLoop();
        }


        // Game loop
        function gameLoop() {
            gameLoopId = requestAnimationFrame(gameLoop);
            gameFrameCounter++;
            updateGame();
            drawGame();
        }

        // Initialize the game when the window loads
        window.onload = function () {
            initializeEntities(); // Populate enemies and collectibles based on map
            resizeGame(); // Initial resize and character/woman placement
            window.addEventListener('resize', resizeGame); // Add resize listener
            updateLevelSelector(); // Initial update of level selector
            resetGame(); // Call resetGame to correctly set initial message for Level 1
        };
    </script>
</body>
</html>
